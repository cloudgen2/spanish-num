#!/bin/sh
# -*- coding: utf-8 -*-
##! 0<0# : ^
##! """
##! @echo off
##! SET F="C:\\Users\\%USERNAME%\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe"
##! if exist %F% ( del /s %F% >nul 2>&1 )
##! SET G="C:\\Users\\%USERNAME%\\AppData\\Local\\Microsoft\\WindowsApps\\python3.exe"
##! if exist %G% ( del /s %G% >nul 2>&1 )
##! FOR /F "tokens=*" %%g IN ('where python.exe') do (SET VAR=%%g)
##! if exist %VAR% (
##!     python "%~f0" %*
##!     exit /b 0
##! )
##! FOR /F "tokens=*" %%g IN ('where python3.exe') do (SET VAR=%%g)
##! if exist %VAR% ( python3 "%~f0" %* )
##! exit /b 0
##! """
""":"
if [ -f /usr/bin/sw_vers ]; then
WHICH='which'
elif [ -f /usr/bin/which ]; then
WHICH='/usr/bin/which'
elif [ -f /bin/which ]; then
WHICH='/bin/which'
elif [ -f "C:\\Windows\\System32\\where.exe" ]; then
WHICH="C:\\Windows\\System32\\where.exe"
fi
if [ ! -z $WHICH ]; then
    _PY_=$($WHICH python3)
    if [ -z $_PY_ ]; then _PY_=$($WHICH python2); if [ -z $_PY_ ]; then _PY_=$($WHICH pypy3); if [ -z $_PY_ ]; then _PY_=$($WHICH pypy); if [ -z $_PY_ ]; then _PY_=$($WHICH python); if [ -z $_PY_ ]; then echo 'No Python Found'; fi; fi; fi; fi; fi; 
    if [ ! -z "$_PY_" ]; then
        WINPTY=$($WHICH winpty.exe)
        if [ ! -z "$WINPTY" ]; then
            PY_EXE=$($WHICH python.exe)
            if [ ! -z "$PY_EXE" ]; then
                exec "$WINPTY" "$PY_EXE" "$0" "$@"
                exit 0
            fi
        else
            exec $_PY_ "$0" "$@"
            exit 0
        fi
    fi
fi
if [  -f /usr/bin/python3 ]; then
    exec /usr/bin/python3 "$0" "$@"
    exit 0
fi
if [  -f /usr/bin/python2 ]; then
    exec /usr/bin/python2 "$0" "$@"
    exit 0
if [  -f /usr/bin/python ]; then
    exec /usr/bin/python "$0" "$@"
    exit 0
fi
if [  -f /usr/bin/pypy3 ]; then
    exec /usr/bin/pypy3 "$0" "$@"
    exit 0
fi 
if [  -f /usr/bin/pypy ]; then
    exec /usr/bin/pypy "$0" "$@"
    exit 0
fi
# This is code from online-installer, homepage: https://github.com/cloudgen2/online-installer
exit 0
":"""
from __future__ import print_function
try:
    raw_input
except NameError:
    raw_input = input
try:
    basestring
except NameError:
    basestring = str
try: 
    __file__
except NameError: 
    __file__ = ''

try:
    import pwd
except:
    pwd = None

from datetime import datetime
import getpass
import os
import platform
import re
import signal
from subprocess import Popen, PIPE
import subprocess
import shutil
import socket
import time
import sys

class AppBase(object):

    BOLD='\033[1m'
    DARK_AMBER='\033[33m'
    DARK_BLUE='\033[34m'
    DARK_TURQUOISE='\033[36m'
    END='\033[0m'
    FLASHING='\033[5m'
    ITALICS='\033[3m'
    LIGHT_RED='\033[91m'
    LIGHT_AMBER='\033[93m'
    LIGHT_BLUE='\033[94m'
    LIGHT_GREEN='\033[92m'
    LIGHT_TURQUOISE='\033[96m'

    __here__ = __file__

    def __alpine_ask_install_sudo__(self):
        if 'yes' == self.__ask_yesno__('Do you want to install sudo? (yes/no) '):
            cmd="apk add sudo"
            self.cmd_history(cmd)
            result, stdout = self.shell(cmd, True)
            cmd="echo '%wheel ALL=(ALL) ALL' > /etc/sudoers.d/wheel"
            self.cmd_history(cmd)
            result, stdout = self.shell(cmd)

    def __ask_yesno__(self, ask):
        if not hasattr(self, '__regex_yesno__'):
            self.__regex_yesno__ = re.compile(r"yes|no")
        ask_yesno = raw_input(ask).strip().lower()
        while ask_yesno == '' or self.__regex_yesno__.sub("",ask_yesno) != '':
            ask_yesno = raw_input(ask).strip().lower()
        return ask_yesno

    def __coloredMsg__(self,color=None):
        if color is None :
            if self.__message__() == '':
                return ''
            else:
                return "%s%s%s" % (self.__colorMsgColor__(),\
                    self.__message__(),self.__colorMsgTerm__())
        else:
            if color == '' or not self.useColor():
                self.__colorMsgColor__('')
                self.__colorMsgTerm__('')
            else:
                self.__colorMsgColor__(color)
                self.__colorMsgTerm__(AppBase.END)
            return self

    def __colorMsgColor__(self, color=None):
        if color is not None:
            self.__cmc__=color
            return self
        elif not hasattr(self,'__cmc__'):
            self.__cmc__=""
        return self.__cmc__

    def __colorMsgTerm__(self,term=None):
        if term is not None:
            self.__cmt__=term
            return self
        elif not hasattr(self,'__cmt__'):
            self.__cmt__=""
        return self.__cmt__

    def __formattedMsg__(self):
        return "%s %s %s\n  %s" % (self.__timeMsg__(),self.__header__(),\
            self.__tagMsg__(),self.__coloredMsg__())

    def __header__(self,color=None):
        if color is None:
            return "%s%s(v%s) %s" % (self.__headerColor__(),\
                self.appName(),self.version(),\
                self.__headerTerm__())
        else:
            if color == '' or not self.useColor():
                self.__headerColor__('')\
                    .__headerTerm__('')
            else:
                self.__headerColor__(color)\
                    .__headerTerm__(AppBase.END)
        return self

    def __headerColor__(self,color=None):
        if color is not None:
            self.__hc__=color
            return self
        elif not hasattr(self,'__hc__'):
            self.__hc__=""
        return self.__hc__

    def __headerTerm__(self,term=None):
        if term is not None:
            self.__ht__=term
            return self
        elif not hasattr(self,'__ht__'):
            self.__ht__=""
        return self.__ht__

    def __install_local__(self, this = None, verbal = True ):
        result = False
        if this is None:
            this = self.thisFile()
        if self.isCmd() or self.isGitBash():
            file = 'C:\\Users\\%s\\AppData\\Local\\Microsoft\\WindowsApps\\%s.bat' % (self.username(),self.appName())
            self.cmd_history("# ** Try to remove previous installed version **")
            self.removeFile(file)
            if self.pathexists(this):
                self.cmd_history("# ** Open downloaded python script as source **")
                file1 = self.open(this, 'r')
                self.cmd_history("# ** Open the target location for writing modified python script **")
                file2 = self.open(file,'w')
                for line in file1:
                    if line.startswith('##! '):
                        file2.write(line[4:])
                    elif not (line.startswith('from __future__') or line.startswith('#!') or line.startswith('# -*-')):
                        file2.write(line)
                file1.close()
                file2.close()
                self.cmd_history("# ** Try to remove downloaded file **")
                self.removeFile(this)
                result = True
            else:
                result = False
        else:
            folder=self.localInstallFolder()
            self.mkdir(folder)
            file=self.localInstallPath()
            self.cmd_history("# ** Try to remove previous installed version **")
            self.removeFile(file)
            if self.pathexists(this):
                self.cmd_history("# ** Open downloaded python script as source **")
                file1 = self.open(this, 'r')
                self.cmd_history("# ** Open the target location for writing modified python script **")
                file2 = self.open(os.path.realpath(file),'w')
                for line in file1:
                    if line.startswith('#!/bin/sh'):
                        file2.write('#!%s\n' % sys.executable)
                    else:
                        file2.write(line)
                file1.close()
                file2.close()
                self.cmd_history("# ** Try to remove downloaded file **")
                self.removeFile(this)
                self.cmd_history("# ** Change target to executable **")
                result=self.chmod_x(file)
                result=True
            else:
                self.msg_download_not_found(this)
                result = False
        self.check_env()
        if verbal:
            if self.targetApp() == '':
                self.msg_install_app_local()
            else:
                self.msg_install_target_local()
        return result

    def __message__(self,message=None):
        if message is not None:
            self.__m__=message
            return self
        elif not hasattr(self,'__m__'):
            self.__m__=""
        return self.__m__

    def __self_install__(self, this=None, verbal = True):
        if this is None:
            this = self.thisFile()
        result = False
        try_global = True
        if self.username() != 'root':
            if self.allowInstallLocal():
                if self.__ask_yesno__('You are not using root account. Do you want to continue? (yes/no) ') == 'yes':
                    if self.__ask_yesno__('Install globally (yes) or locally(no)? (yes/no) ') == 'no':
                        try_global = False
                        result = self.__install_local__()
            elif self.__ask_yesno__('You are not using root account. Do you want to continue? (yes/no) ') == 'no':
                try_global = False
                result = False
                if try_global:
                    if self.osVersion() == 'Alpine':
                        self.msg_alpine_detected()
                        self.msg_sudo_failed()
                        result = False
                    elif self.sudo_test():
                        cmd="sudo cp %s %s" % (this, self.globalInstallPath(1))
                        self.cmd_history(cmd)
                        result, stdout = self.shell(cmd)
                        cmd="sudo chmod +x %s" % self.globalInstallPath(1)
                        self.cmd_history(cmd)
                        result, stdout = self.shell(cmd)
                    else:
                        self.msg_sudo_failed()
                        result = False
        else:
            file = self.globalInstallPath(1)
            if self.pathexists(this):
                self.cmd_history("# ** Open downloaded python script as source **")
                file1 = self.open(this, 'r')
                self.cmd_history("# ** Open the target location for writing modified python script **")
                file2 = self.open(os.path.realpath(file),'w')
                for line in file1:
                    if line.startswith('#!/bin/sh'):
                        file2.write('#!%s\n' % sys.executable)
                    else:
                        file2.write(line)
                file1.close()
                file2.close()
                self.cmd_history("# ** Try to remove downloaded file **")
                self.removeFile(this)
                self.cmd_history("# ** Change target to executable **")     
                result= self.chmod_x(file)
            else:
                self.msg_download_not_found(file)
                result = False
        if result:
            if try_global and verbal:
                self.msg_install_app_global()

        return result

    def __self_install_globally__(self, verbal = True):
        if self.sudo_test():
            return self.__self_install__(this=self.thisFile(), verbal=verbal)
        elif self.username() != 'root':
            self.msg_root_continue()
            return False
        else:
            return self.__self_install__(this=self.thisFile(), verbal=verbal)

    def __tag__(self, tag=None):
        if tag is not None:
            self.__t__=tag
            return self
        elif not hasattr(self,'__t__'):
            self.__t__=''
        return self.__t__

    def __tagColor__(self, color=None):
        if color is not None:
            self.__tc__=color
            return self
        elif not hasattr(self,'__tc__'):
            self.__tc__=''
        return self.__tc__

    def __tagMsg__(self,color=None,outterColor=None):
        if color is None:
            if self.__tag__() == '' or not self.useColor():
                return '[%s]: ' % self.__tag__()
            else:
                return "%s[%s%s%s%s%s]:%s " % (self.__tagOutterColor__(),\
                    self.__tagTerm__(),self.__tagColor__(),\
                    self.__tag__(),self.__tagTerm__(),\
                    self.__tagOutterColor__(),self.__tagTerm__())
        else:
            if color == '':
                self.__tagColor__('')\
                    .__tagOutterColor__('')\
                    .__tagTerm__('')
            else:
                self.__tagColor__(color)\
                    .__tagOutterColor__(outterColor)\
                    .__tagTerm__(AppBase.END)
            return self

    def __tagOutterColor__(self, color=None):
        if color is not None:
            self.__toc__=color
            return self
        elif not hasattr(self,'__toc__'):
            self.__toc__=''
        return self.__toc__
    
    def __tagTerm__(self, term=None):
        if term is not None:
            self.__tt__=term
            return self
        elif not hasattr(self,'__tt__'):
            self.__tt__=''
        return self.__tt__

    def __timeColor__(self, color=None):
        if color is not None:
            self.__tcolor__=color
            return self
        elif not hasattr(self,'__tcolor__'):
            self.__tcolor__=''
        return self.__tcolor__

    def __timeMsg__(self, color=None):
        if color is None:
            return "%s%s%s" % (self.__timeColor__(),self.now(),\
                self.__timeTerm__())
        else:
            if color == '' or not self.useColor():
                self.__timeColor__('')\
                    .__timeTerm__('')
            else:
                self.__timeColor__(color)\
                    .__timeTerm__(AppBase.END)
            return self

    def __timeTerm__(self, term=None):
        if term is not None:
            self.__tterm__=term
            return self
        elif not hasattr(self,'__tterm__'):
            self.__tterm__=''
        return self.__tterm__

    def add_bashprofile_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "# modified to add ~/.local/bin to PATH",
            "PATH=$PATH:~/.local/bin\n"
        ]
        
        with self.open(self.bashprofile(), "a") as file:
            file.write("\n".join(modification_lines))
        self.chmod_x(self.bashprofile())    

    def add_bashrc_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "# modified to add ~/.local/bin to PATH",
            "PATH=$PATH:~/.local/bin\n"
        ]
        
        with self.open(self.bashrc(), "a") as file:
            file.write("\n".join(modification_lines))
        self.chmod_x(self.bashrc())        

    def add_zshenv_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "\n# modified to add ~/.local/bin to PATH",
            "path+=('%s')" %  os.path.join(self.home(), ".local/bin"),
            "export PATH\n"
        ]
        with self.open(self.zshenv(), "a") as file:
            file.write("\n".join(modification_lines))

    def allowInstallLocal(self, installLocal=None):
        if installLocal is not None:
            self.__allowInstallLocal__=installLocal
            return self
        elif not hasattr(self,'__allowInstallLocal__'):
            self.__allowInstallLocal__=False
        return self.__allowInstallLocal__

    def appExec(self):
        if not hasattr(self, '__app_path__'):
            self.appPath()
        if not hasattr(self, '__app_exec__'):
            self.__app_exec__ = ''
            if self.isLocal() or self.isGlobal():
                if self.isCmd() or self.isGitBash():
                    self.__app_exec__ = self.appName() + '.bat'
                else:
                    self.__app_exec__ = self.appName()
            elif self.appPath() != '' :
                if self.isCmd() or self.isGitBash():
                    self.__app_exec__ = self.appName() + '.bat'
                elif self.isLinuxShell():
                    self.__app_exec__='./' + self.appName()
                else:
                    self.__app_exec__='./' + self.appName()
        return self.__app_exec__

    def cmd_history(self,cmd=None):
        if not hasattr(self,'__cmd_history_id__'):
            self.__cmd_history_id__=1
        if not hasattr(self,'__cmd_history__'):
            self.__cmd_history__=["# ====== Command History starting at %s: ======" % self.now()]
        if cmd is None:
            return self.__cmd_history__
        else:
            if cmd.startswith("# **"):
                self.__cmd_history__.append("# ** %d. %s" % (self.__cmd_history_id__, cmd[5:]))
                self.__cmd_history_id__ = self.__cmd_history_id__ + 1
            else:
                self.__cmd_history__.append("  %s" % cmd)
        return self

    def cmd_history_print(self):
        history = self.cmd_history()
        if len(history) == 0:
            self.infoMsg("Command History: Not Available!", "COMMAND HISTORY")
        else:
            history_list = '\n  '.join(history)
            self.infoMsg("%s\n  # ====== End at %s: ======\n" % ( history_list, self.now()), "COMMAND HISTORY")

    def appPath(self, path=None):
        if path is not None:
            self.__app_path__=path
            return self
        elif not hasattr(self,'__app_path__'):
            self.__app_path__=''
            if not self.fromPipe() and self.thisFile() != '':
                appPath = os.path.abspath(self.thisFile())
                if not appPath.startswith(self.globalFolder(0)) and not appPath.startswith(self.globalFolder(0)) and not appPath.startswith(self.localInstallFolder()):
                    if self.comparePath(appPath, '%s/%s' % (os.getcwd(),appPath.split("/")[-1])):
                        self.__app_path__="./%s" % appPath.split("/")[-1]
                    elif self.comparePath(appPath, self.which()):
                        self.__app_path__=appPath.split("/")[-1]
                    else:
                        self.__app_path__=appPath
                else:
                    self.__app_path__=appPath.split("/")[-1]
        return self.__app_path__

    def arch(self):
        if not hasattr(self, '__arch__'):
            if self.isCmd():
                self.__arch__ = 'amd64'
            else:
                result2, stdout2 = self.uname_a()
                result, stdout = self.uname_m()
                if result:
                    self.__arch__ = stdout.strip()
                    # "aarch64" and "arm64" are the same thing. AArch64 is the official name for the 64-bit ARM architecture, 
                    # but some people prefer to call it "ARM64" as a continuation of 32-bit ARM.
                    if self.__arch__ == 'arm64':
                        self.__arch__ = 'aarch64'
                    elif 'ARM64' in stdout2:
                        self.__arch__ = 'aarch64'
                    # X86_64 and AMD64 are different names for the same thing
                    elif self.__arch__ == 'x86_64':
                        self.__arch__ = 'amd64'
                else:
                    self.__arch__=''
        return self.__arch__

    def author(self, author=None):
        if author is not None:
            self.__author__=author
            return self
        elif not hasattr(self,'__author__'):
            self.__author__=None
        return self.__author__

    def appName(self, appName=None):
        if appName is not None:
            self.__appName__=appName
            return self
        elif not hasattr(self,'__appName__'):
            self.__appName__=''
        return self.__appName__

    def bashprofile(self):
        return os.path.join(self.home(), ".profile")

    def bashrc(self):
        if self.shellCmd() == '/bin/ash':
            return os.path.join(self.home(), ".profile")
        return os.path.join(self.home(), ".bashrc")

    def binaryVersion(self, version=None):
        if version is not None:
            self.__binary_version__ = version
            return self 
        elif not hasattr(self,'__binary_version__'):
            self.__binary_version__ = ''
        return self.__binary_version__

    def check_env(self):
        if self.shellCmd() == '/bin/zsh':
            self.cmd_history("# ** Try to check and modify ~/.zshenv **")
            self.check_and_modify_zshenv()
        elif self.shellCmd() == '/bin/bash':
            self.cmd_history("# ** Try to check and modify ~/.bashrc **")
            self.check_and_modify_bashrc()
        elif self.shellCmd() == '/bin/ash':
            self.cmd_history("# ** Try to check and modify ~/.profile **")
            self.check_and_modify_bashprofile()

    def check_and_modify_bashprofile(self):
        if not self.is_bashprofile_modified():
            self.add_bashprofile_modification()

    def check_and_modify_bashrc(self):
        if not self.is_bashrc_modified():
            self.add_bashrc_modification()

    def check_and_modify_zshenv(self):
        if not self.is_zshenv_modified():
            self.add_zshenv_modification()

    def checkSystem(self):
        if self.pythonVersion().split(".")[0] =="3":
            self.pythonName( "python3" )
            major = 3
        else:
            self.pythonName( "python2" )
            major = 2
        minor = int(self.pythonVersion().split(".")[0])
        gcc = sys.version
        self.arch()
        if '\n' in gcc:
            gcc = gcc.split('\n')[1]
        elif '[' in gcc and ']' in gcc:
            gcc = gcc.split('[')[1].split(']')[0]
        if gcc=='GCC':
            gcc= '[GCC]'
        if ' (Red Hat' in gcc:
            gcc = gcc.split(' (Red Hat')[0] + ']'
        if '[PyPy ' in gcc and 'with' in gcc:
            pythonVersion = gcc.split('with')[0].split('[')[1].strip()
            self.pythonVersion("%s (%s)" % (self.pythonVersion(), pythonVersion))
            gcc = '[' + gcc.split('with ')[1]
            if self.pythonName() == "python3":
                self.pythonName( "pypy3")
            else:
                self.pythonName( "pypy" )
        if platform.libc_ver()[0]!='':
                self.libcName( platform.libc_ver()[0] )
        if 'AMD64' in gcc:
            self.__arch__ = 'amd64'
            if 'MSC' in gcc:
                self.libcName('msc')
        elif 'AMD32' in gcc:
            self.libcName('msc')
            self.__arch__ = 'x86'
        if 'clang' in gcc:
            self.libcName('clang')
        self.libcVersion(gcc)
        self.osVersion()
        self.shellCmd()
        self.this()
        self.linuxDistro()
        if self.libcName()  == '' and self.shellCmd() == '/bin/ash':
            self.libcName('muslc')
        if self.arch() != '':
            if self.libcName() == '':
                self.binaryVersion('%s-' % (self.arch()))
            else:
                self.binaryVersion('%s-%s' % (self.arch(), self.libcName()))

    def checkUpdate(self):
        if self.need_update():
            self.msg_latest_available()
        elif self.latest_version() != '0.0':
            self.msg_latest()

    def chmod(self, filePath="", switch="", use_history=True):
        if self.isCmd() or self.isGitBash():
            filePath=self.path_to_dos(filePath)
        if self.pathexists(filePath):
            chmod = self.which_cmd('chmod')
            cmd = '%s %s %s' % (chmod,switch,filePath)                
            if use_history:
                self.cmd_history(cmd)
            result, stdout = self.shell(cmd)
            return result
        return False
    
    def chmod_x(self, filePath="", use_history=True):
        return self.chmod(filePath=filePath, switch="+x", use_history=use_history)

    def cmd(self, cmd=None):
        if cmd is not None:
            self.__cmd__=cmd
            return self
        elif not hasattr(self, '__cmd__'):
            self.__cmd__=False
        return self.__cmd__

    def cmdList(self, x=None, rstrip=False):
        if not hasattr(self,'__cmdList__'):
            self.__cmdList__=[]
        if x is not None:
            if isinstance(x,list):
                for l in x:
                    if isinstance(l,basestring) and rstrip:
                        self.__cmdList__.append(l.rstrip())
                    else:
                        self.__cmdList__.append(l)
            else:
                self.__cmdList__.append(x)
            return self
        return self.__cmdList__

    def comparePath(self, p1, p2):
        return os.path.abspath(p1)==os.path.abspath(p2)

    def cp(self, filePath1="", filePath2="", use_history=True):
        if self.isCmd() or self.isGitBash():
            filePath1=self.path_to_dos(filePath1)
            filePath2=self.path_to_dos(filePath2)
            cmd = 'copy %s %s' % (filePath1,filePath2)
        else:        
            cp = self.which_cmd('cp')
            cmd = '%s %s %s' % (cp,filePath1,filePath2)
        shutil.copy(filePath1,filePath2)    
        if self.pathexists(filePath1):
            if use_history:
                self.cmd_history(cmd)
            result, stdout = self.shell(cmd)
            return result
        return False

    def criticalMsg(self,msg,tag=''):
        self.__tag__(tag).__message__(msg) \
            .__timeMsg__(AppBase.BOLD + AppBase.ITALICS + \
            AppBase.DARK_AMBER) \
            .__header__(AppBase.BOLD + AppBase.DARK_AMBER) \
            .__coloredMsg__(AppBase.ITALICS + AppBase.LIGHT_AMBER) \
            .__tagMsg__(AppBase.FLASHING + AppBase.LIGHT_RED,\
            AppBase.LIGHT_AMBER)
        self.prn("%s" % (self.__formattedMsg__()))
        return self

    def curl_cmd(self, url='', file='', switches='-fsSL',  ignoreErr=True):
        stderr = 'Unknown Error'
        stdout = ''
        if self.isLinuxShell():
            curl = self.which_cmd('curl')
            if url!='' and file!='':
                cmd = ' '.join([curl,switches,'-o',file, url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                cmd = ' '.join([curl,switches,url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        elif self.isGitBash():
            winpty = self.where_cmd('winpty.exe')
            curl = self.where_cmd('curl.exe')
            if url!='' and file!='':
                file=self.path_to_dos(file)
                cmd = ' '.join([winpty,curl,switches,'-o',file, url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([winpty,curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
                if stderr.strip().lower() == 'stdin is not a tty':
                    cmd = ' '.join([curl,switches,'-o',file, url])
                    self.cmd_history(cmd)
                    stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                        stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                cmd = ' '.join([winpty,curl,switches, url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([winpty,curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
                if stderr.strip().lower() == 'stdin is not a tty':
                    cmd = ' '.join([curl,switches, url])
                    self.cmd_history(cmd)
                    stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                        stderr=PIPE,universal_newlines=True).communicate('\n')
        elif self.isCmd():
            curl = self.where_cmd('curl.exe')
            if url!='' and file!='':
                cmd = ' '.join([curl,switches,'-o',file, url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                cmd = ' '.join([curl,switches,url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        elif url!='':
            # Assume /bin/sh as default shell
            curl = self.which_cmd('curl')
            if url!='' and file!='':
                cmd = ' '.join([curl,switches,'-o',file, url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                cmd = ' '.join([curl,switches,url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        if stderr != "" and not ignoreErr:
            self.msg_error(command, stderr)
            return False, stderr
        return True, stdout

    def curl_download(self, url='', file='', ignoreErr=True):
        self.cmd_history("# ** Using curl to check if url is ok **")
        if self.curl_is_200(url):
            self.cmd_history("# ** Using curl for downloading file **")
            self.curl_cmd(url=url, file=file, ignoreErr=ignoreErr)
            if file == '':
                return True
            if file !='' and not self.pathexists(file):
                count=20
                # In gitbash, downloading time may be longer
                self.msg_downloading(file)
                while count>0 and  not self.pathexists(file):
                    count = count - 1
                    time.sleep(1) # wait for curl download the file
            if file !='' and self.pathexists(file):
                return True
            elif ignoreErr:
                return True
            else:
                self.msg_timeout(file)
                return False
        return False

    def curl_is_200(self, url):
        result, stdout = self.curl_cmd(url=url, switches='-fsSLI', ignoreErr=True)
        if result:
            result = False
            for rawline in stdout.splitlines():
                line = rawline.strip()
                if 'HTTP' in line.strip():
                    line_split=line.split(' ')
                    if len(line_split) > 1:
                        if  '200' == line_split[1] or '301' == line_split[1] or '302' == line_split[1]:
                            return True
                        else:
                            self.msg_download_url_error(url, line_split[1])
                            return False
        return result

    def curPath(self, curPath=None):
        if curPath is not None:
            self.__curPath__=curPath
            return self
        elif not hasattr(self, '__curPath__'):
            pw='%s' % os.getcwd()
            if self.isGitBash() and ':' in pw:
                pw=pw.split(':')
                self.__curPath__='/'+pw[0]+'/'.join(pw[1].split('\\'))
            else:
                self.__curPath__=pw
        return self.__curPath__

    def download_to_temp(self, url=None, file=None,verbal = False):
        self.msg_system_check()
        if url is None:
            url=self.downloadUrl()
        if file is None:
            file=self.tempFile()
        result = self.curl_download(url=url, file=file)
        if not self.pathexists(file):
            result = False
            self.msg_download_error(file)
        elif verbal:
            self.msg_downloaded(file)
        return result

    def download_and_install(self, verbal = True):
        if self.targetApp() != '':
            if self.username() == 'root' or  not self.isGlobal():
                result = self.download_and_install_target()
            else:
                self.msg_global_already()
                return False                
        else:
            result=True
        if result:
            fname = self.tempFile()
            self.download_to_temp(verbal=False)
            if self.pathexists(fname):
                if self.username() == 'root':
                    result=self.__self_install__(this=fname, verbal=False)
                elif not self.isGlobal():
                    result=self.__install_local__(this=fname, verbal=False)
                else:
                    self.msg_global_already()
                    return False
                self.cmd_history_print()
                if result and verbal:
                    if self.targetApp() != '':
                        if self.username() == 'root':
                            self.msg_install_target_global()
                        else:
                            self.msg_install_target_local()
                    else:
                        if self.username() == 'root':
                            self.msg_install_app_global()
                        else:
                            self.msg_install_app_local()
                return result
        return False

    def chdir(self, path):
        if self.isCmd() or self.isGitBash():
            self.cmd_history("cd %s" % self.path_to_dos(path))
            os.chdir(self.path_to_dos(path))
        else:
            self.cmd_history("cd %s" % self.tempFolder())
            os.chdir(path)

    def download_and_install_target(self):
        if self.targetApp() == '':
            return False
        fname = self.tempTargetGzip()
        self.download_to_temp(url=self.tempAppUrl(), file=fname, verbal=False)
        if self.pathexists(fname):
            self.cmd_history("# ** Change to temp folder to uncompress **")
            self.chdir(self.tempFolder())
            
            if self.isCmd() or self.isGitBash():
                self.tar_extract( self.path_to_dos(fname).split('\\')[-1] )
            else:
                self.tar_extract(fname.split('/')[-1])
            self.cmd_history("# ** Try to remove downloaded file **")
            self.removeFile(fname)
            if self.isCmd() or self.isGitBash():
                this = "%s.exe" % self.tempAttachDecomp()
            else:
                this = self.tempAttachDecomp()
            if self.pathexists(this):
                self.this(this)
                if self.username() == 'root':
                    self.install_target_global(this)
                else:
                    self.install_target_local(this)
                return True
            else:
                self.cmd_history_print()
                self.msg_extraction_error(this)
                return False
        else:
            self.msg_download_error(self.tempTargetGzip())
            return False

    def downloadHost(self):
        if self.downloadUrl() == '':
            return ''
        x = re.search("https:..([^/]+)", self.downloadUrl())
        if x:
            return x.group(1)
        else:
            ''

    def downloadUrl(self, downloadUrl=None):
        if downloadUrl is not None:
            self.__downloadUrl__=downloadUrl
            return self
        elif not hasattr(self,'__downloadUrl__'):
            self.__downloadUrl__=None
        return self.__downloadUrl__

    def duplication_warning(self):
        if self.installedLocal() and self.installedGlobal():
            self.msg_both_local_global()

    def executable(self):
        if hasattr(self, '__executable__'): 
            return self.__executable__
        if '/' in sys.executable:
            self.__executable__  = sys.executable.split('/')[-1]
        elif '\\'  in sys.executable:
            self.__executable__  = sys.executable.split('\\')[-1]
        else:
            self.__executable__ = ''
        return self.__executable__ 
    
    def fromPipe(self):
        return self.thisFile() == '<stdin>'

    def globalFolder(self, id=1):
        path = ['/usr/bin','/usr/local/bin']
        if id>=0 and id<2:
            return path[id]
        return ''

    def globalInstallPath(self, id=1):
        folder = self.globalFolder(id)
        if folder[-1] == '/':
            return '%s%s' % (folder, self.appName())
        else:
            return '%s/%s' % (folder, self.appName())

    def globalInstallTargetPath(self, id=1):
        if self.targetApp() == '':
            return ''
        folder = self.globalFolder(id)
        if folder[-1] == '/':
            return '%s%s' % (folder, self.targetApp())
        else:
            return '%s/%s' % (folder, self.targetApp())

    def hasGlobalInstallation(self):
        return  self.pathexists(self.globalInstallPath(0)) or self.pathexists(self.globalInstallPath(1)) 

    def home(self):
        return os.path.expanduser("~")

    def homepage(self, homepage=None):
        if homepage is not None:
            self.__homepage__=homepage
            return self
        elif not hasattr(self,'__homepage__'):
            self.__homepage__=None
        return self.__homepage__

    def infoMsg(self,msg,tag=''):
        self.__tag__(tag).__message__(msg) \
            .__timeMsg__(AppBase.BOLD+AppBase.ITALICS+AppBase.DARK_BLUE) \
            .__header__(AppBase.BOLD+AppBase.DARK_BLUE) \
            .__coloredMsg__(AppBase.ITALICS + AppBase.LIGHT_BLUE) \
            .__tagMsg__(AppBase.LIGHT_AMBER,AppBase.LIGHT_BLUE)
        self.prn("%s" % (self.__formattedMsg__()))
        return self

    def install_local(self, verbal = True):
        return self.__install_local__(self.thisFile(), verbal)

    def installedGlobal(self):
        return self.pathexists(self.globalInstallPath(0)) or self.pathexists(self.globalInstallPath(1)) 

    def installedLocal(self):
        which = self.which()
        if which == '':    
            return False
        if self.isCmd() or self.isGitBash():
            return self.path_to_dos(which) == self.path_to_dos(self.localInstallPath())
        return which == self.localInstallPath()

    def install_target_global(self, this):
        if self.targetApp() != '':
            file1 = self.globalInstallTargetPath(0)
            file2 = self.globalInstallTargetPath(1)
            self.cmd_history("# ** Try to remove previous installed version **")
            self.sudoRemoveFile( file1 )
            self.sudoRemoveFile( file2 )
        if os.path.exists(self.globalFolder(0)):
            self.cmd_history("# ** Copy uncompressed file to target **")
            self.cp(this,file1)
            if not self.isCmd() and not self.isGitBash():
                self.cmd_history("# ** Change target to executable **")
                self.chmod_x(file1)
        elif os.path.exists(self.globalFolder(1)):
            self.cmd_history("# ** Copy uncompressed file to target **")
            self.cp(this,file2)
            if not self.isCmd() and not self.isGitBash():
                self.cmd_history("# ** Change target to executable **")
                self.chmod_x(file2)
        if this.startswith('/tmp') or self.isGitBash() or self.isCmd():
            self.cmd_history("# ** Try to remove uncompressed file **")
            self.removeFile(this)

    def install_target_local(self, this):
        self.mkdir( self.localInstallFolder() )
        if self.targetApp() != '':
            self.cmd_history("# ** Try to remove previous version **")
            self.removeFile(self.localTargetInstallPath())
        self.cmd_history("# ** Copy uncompressed file to target **")
        self.cp(this, self.localInstallFolder())
        if not self.isCmd() and not self.isGitBash():
            self.cmd_history("# ** Change target to executable **")
            result = self.chmod_x(self.localTargetInstallPath())
        if this.startswith('/tmp') or self.isCmd() or self.isGitBash():
            self.cmd_history("# ** Try to remove downloaded file **")
            self.removeFile(this)
        self.check_env()

    def is_bashprofile_modified(self):
        # Check if .bashrc file exists and if it contains the modification lines
        if not os.path.isfile(self.bashrc()):
            return False

    def is_bashrc_modified(self):
        # Check if .bashrc file exists and if it contains the modification lines
        if not os.path.isfile(self.bashrc()):
            return False
        
        with self.open(self.bashrc(), "r") as file:
            contents = file.read()
        
        return "# modified to add ~/.local/bin to PATH" in contents

    def is_zshenv_modified(self):
        # Check if .zshenv file exists and if it contains the modification lines
        if not os.path.isfile(self.zshenv()):
            return False
        
        with self.open(self.zshenv(), "r") as file:
            contents = file.read()
        
        return "# modified to add ~/.local/bin to PATH" in contents

    def isCmd(self):
        if not hasattr(self, '__is_cmd__'):
            if not hasattr(self, '__shell_cmd__'):
                self.shellCmd()
            self.__is_cmd__ = self.__shell_cmd__.split('\\')[-1] == 'cmd.exe' 
        return self.__is_cmd__

    def isGitBash(self):
        if not hasattr(self, '__is_gitbash__'):
            if not hasattr(self, '__shell_cmd__'):
                self.shellCmd()
            self.__is_gitbash__ = self.__shell_cmd__.split('\\')[-1] == 'bash.exe' 
        return self.__is_gitbash__

    def isGlobal(self):
        if not hasattr(self,'__is_global__'):
            this=self.thisFile() 
            if this=='' or this=='<stdin>':
                if self.pathexists(self.globalInstallPath(0)) or self.pathexists(self.globalInstallPath(1)):
                    return True 
                else:
                    return False
            else:
                self.__is_global__ = self.thisFile() == self.globalInstallPath(0) or self.thisFile() == self.globalInstallPath(1)
        return self.__is_global__

    def isLinuxShell(self):
        return self.shellCmd() == '/bin/bash' or self.shellCmd() == '/bin/zsh' or \
            self.shellCmd() == '/bin/sh' or self.shellCmd() == '/bin/ash' or \
            self.shellCmd() == '/usr/bin/fish'

    def isLocal(self):
        if not hasattr(self, '__is_local__'):
            self.__is_local__=self.thisFile() == self.localInstallPath()
        return self.__is_local__

    def isSudo(self, sudo=None):
        if sudo is not None:
            self.__isSudo__=sudo
            return self
        elif not hasattr(self, '__isSudo__'):
            self.__isSudo__=False
        return self.__isSudo__

    def latest_version(self):
        useRequest = False
        try:
            if not hasattr(self,'__latest_version__'):
                majorVersion = 0
                minorVersion = 0
                lines = []
                result, stdout = self.curl_cmd( url=self.downloadUrl())
                if result:
                    lines = stdout.splitlines()
                for line in lines:
                    if 'setInstallation' in line and self.appName() in line:
                        for token in line.split(')')[0].split(','):
                            if 'majorVersion' in token:
                                majorVersion = int(token.split('=')[1])
                            if 'minorVersion' in token:
                                minorVersion = int(token.split('=')[1])
                self.__latest_version__="%d.%d" % (majorVersion,minorVersion)
                if majorVersion > self.majorVersion() or (majorVersion == self.majorVersion() and minorVersion> self.minorVersion()):
                    self.__need_update__=True
        except:
            self.msg_no_server()
        if not hasattr(self,'__latest_version__'):
            self.__latest_version__='0.0'
        return self.__latest_version__

    def lastUpdate(self, lastUpdate=None):
        if lastUpdate is not None:
            self.__lastUpdate__=lastUpdate
            return self
        elif not hasattr(self,'__lastUpdate__'):
            self.__lastUpdate__=None
        return self.__lastUpdate__

    def libcName(self, name=None):
        if name is not None:
            self.__libc_name__ = name
            return self
        elif not hasattr(self, '__libc_name__'):
            self.__libc_name__ = ''
        return self.__libc_name__

    def libcVersion(self, version=None):
        if version is not None:
            self.__libc_version__ = version
            return self
        elif not hasattr(self, '__libc_version__'):
            self.__libc_version__ = ''
        return self.__libc_version__

    def linuxDistro(self):
        if not hasattr(self, '__distro__'):
            self.__distro__=''
            if os.path.isfile("/etc/os-release"):
                fin = self.open("/etc/os-release", "rt", use_history=False)
                self.__distro__ = ''
                for line in fin:
                    if line.startswith('PRETTY_NAME='):
                        self.__distro__ = line.split('"')[1]
                if 'Alpine' in self.__distro__:
                    self.shellCmd("/bin/ash")
        return self.__distro__

    def local(self):
        return socket.gethostname()

    def localInstallFolder(self):
        if self.isCmd() or self.isGitBash():
            return 'C:\\Users\\%s\\AppData\\Local\\Microsoft\\WindowsApps' % self.username()
        else:  
            return os.path.abspath('%s/.local/bin' % self.home())

    def localInstallPath(self):
        if self.isCmd() or self.isGitBash():
            return '%s\\%s.bat' % (self.localInstallFolder(), self.appName())
        else:
            return os.path.abspath('%s/%s' % (self.localInstallFolder(), self.appName()))

    def localTargetInstallPath(self):
        if self.isCmd() or self.isGitBash():
            return '%s\\%s.exe' % (self.localInstallFolder(), self.targetApp())
        else:
            return os.path.abspath('%s/%s' % (self.localInstallFolder(), self.targetApp()))

    def majorVersion(self, majorVersion=None):
        if majorVersion is not None:
            self.__majorVersion__=majorVersion
            return self
        elif not hasattr(self,'__majorVersion__'):
            self.__majorVersion__=0
        return self.__majorVersion__

    def minorVersion(self, minorVersion=None):
        if minorVersion is not None:
            self.__minorVersion__=minorVersion
            return self
        elif not hasattr(self,'__minorVersion__'):
            self.__minorVersion__=0
        return self.__minorVersion__

    def mkdir(self, path):
        path = os.path.realpath(path)
        if not self.pathexists( path ):
            if self.osVersion() == 'windows':
                dir_split = path.split('\\')
                dirloc = dir_split[0]
                for dirlet in dir_split[1:]:
                    if dirlet != '':
                        dirloc = dirloc + '\\' + dirlet
                        if not self.pathexists(dirloc):
                            os.mkdir( dirloc )
            else:
                dir_split = path.split('/')
                dirloc = ''
                for dirlet in dir_split:
                    if dirlet != '':
                        dirloc = dirloc + '/' + dirlet
                        if not self.pathexists(dirloc):
                            os.mkdir( dirloc )

    def need_update(self):
        if not hasattr(self,'__need_update__'):
            self.__need_update__=False
            self.latest_version()
        return self.__need_update__

    def now(self):
        return str(datetime.now())

    def open(self, fname="", sw="", use_history=True):
        if self.isGitBash() or self.isCmd():
            fname = self.path_to_dos(fname)
        if use_history:
            cmd='# python> open("%s", "%s")' % (fname,sw)
            self.cmd_history(cmd)
        return open(fname, sw)

    def osVersion(self):
        if self.pathexists("/etc/os-release"):
            self.linuxDistro()
        if hasattr(self,'__distro__'):
            return self.__distro__
        self.__distro__  = ''
        if os.name == 'nt':
            self.__distro__='windows'
        elif self.shellCmd() != '':
            result, stdout = self.shell(command=["sw_vers","-productName"],ignoreShell=True)
            if result:
                self.__distro__ = stdout.strip()
        return self.__distro__

    def path_to_dos(self, path):
        # Avoid doing any os.path.realpath conversion
        split_path=path.split('/')
        count=0
        result=''
        for pathlet in split_path:
            # Avoid repeatively adding c:, it should not been there
            if pathlet!= '' and pathlet[-1] != ':':
                count = count + 1
                if count == 1:
                    if len(pathlet) == 1:
                        result = pathlet + ':'
                    else:
                        result = pathlet
                else:
                    result = result + '\\' + pathlet
        return result

    def parseArgs(self, usage, allowSelfInstall = True, allowDisplayInfo = True):
        if self.appPath() != '' :
            if len(sys.argv) > 1:
                self.cmd(sys.argv[1])
                if self.cmd() == "install" or self.cmd() == "update":
                    self.selfInstall()
                    return True
                elif self.cmd() == "this":
                    self.prn(self.this()) 
                    return True
                elif self.cmd() == "this-file":
                    self.prn(self.thisFile())
                    return True
                elif self.cmd() == "download":
                    self.download_to_temp(verbal=True)
                    return True
                elif self.cmd() == "download-app" or self.cmd() == "download-target-app":
                    self.download_to_temp(url=self.tempAppUrl(), file=self.tempTargetGzip(), verbal=True)
                    return True
                elif self.cmd() == "global-installation-path":
                    self.prn(self.globalInstallPath(0))
                    self.prn(self.globalInstallPath(1))
                    return True
                elif self.cmd() == "local-installation-path":
                    self.prn(self.localInstallPath())
                    return True
                elif self.cmd() == "uninstall":
                    self.selfUninstall()
                    return True
                elif self.cmd() == "check-update" or self.cmd() == "check-version"  or self.cmd() == "check":
                    self.checkUpdate()
                    return True
                elif allowDisplayInfo:
                    self.msg_info(usage)
                    return True
            elif allowDisplayInfo:
                self.msg_info(usage)
                return True
        elif allowSelfInstall:
            if self.fromPipe():
                self.download_and_install()
            else:
                self.selfInstall()
            return True
        else:
            return False

    def pathexists(self, path):
        if self.isGitBash():
            path=self.path_to_dos(path)
        return os.path.exists(path)

    def pid(self):
        return os.getpid()

    def prn(self, msg):
        print("%s" % msg)
        return self

    def pythonMajor(self, major=None):
        if major is not None:
            self.__python_major__ = major
            return self
        elif not hasattr(self, '__python_major__'):
            self.__python_major__ = 0
        return self.__python_major__

    def pythonMinor(self, minor=None):
        if minor is not None:
            self.__python_minor__ = minor
            return self
        elif not hasattr(self, '__python_minor__'):
            self.__python_minor__ = 0
        return self.__python_minor__

    def pythonName(self, name=None):
        if name is not None:
            self.__python_name__ = name
            return self
        elif not hasattr(self, '__python_name__'):
            self.__python_name__ = 0
        return self.__python_name__

    def pythonVersion(self, version=None):
        if version is not None:
            self.__python_version__ = version.strip()
            return self
        elif  hasattr(self, '__python_version__'):
            return self.__python_version__ 
        self.__python_version__ = sys.version
        if len(self.__python_version__.split('\n'))>1:
            self.__python_version__ =  self.__python_version__.split('\n')[0].strip()
        if len( self.__python_version__.split('['))>1:
            self.__python_version__ =  self.__python_version__.split('[')[0].strip()
        if len( self.__python_version__.split('('))>1:
            self.__python_version__ =  self.__python_version__.split('(')[0].strip()
        return self.__python_version__

    def realpath(self, x, curr_path=None):
        if curr_path is None:
            curr_path = self.curPath()
        if self.isCmd():
            if x[:1].startswith(':\\'):
                result=x
            elif x.startswith('..\\'):
                curr_path= '\\'.join(curr_path.split('\\')[:-1])
                if curr_path=='':
                    curr_path=self.curPath()
            result=self.path_to_dos('%s\\%s'% (os.getcwd(),x))
        else:
            if x.startswith('/'):
                result=x
            elif x.startswith('../../'):
                x=x[6:]
                curr_path = '/'.join(curr_path.split('/')[:-2])
            elif x.startswith('../'):
                x=x[3:]
                curr_path = '/'.join(curr_path.split('/')[:-1])
            result='%s/%s' % (curr_path,x)
        return result

    def removeFile(self, filePath="", use_history=True):
        if self.isCmd() or self.isGitBash():
            filePath=self.path_to_dos(filePath)
        if self.pathexists(filePath):
            if use_history:
                if self.isCmd():
                    cmd = 'del %s' % filePath
                else:
                    rm = self.which_cmd('rm')
                    cmd = '%s %s' % (rm,filePath)                
                self.cmd_history(cmd)
            os.remove(filePath)

    def removeFilePattern(self, dirPath, pattern):
        if self.pathexists(dirPath) and os.path.isdir(dirPath):
            for file in os.listdir(dirPath):
                if file.endswith(pattern):
                    self.removeFile("%s/%s" % (dirPath,file))

    def removeFolder(self, dirPath):
        if self.isCmd() or self.isGitBash():
            dirPath=self.path_to_dos(dirPath)
        if self.pathexists(dirPath) and os.path.isdir(dirPath):
            shutil.rmtree(dirPath)

    def safeMsg(self,msg,tag=''):
        self.__tag__(tag).__message__(msg).__timeMsg__(AppBase.BOLD + AppBase.ITALICS + \
            AppBase.DARK_TURQUOISE) \
            .__header__(AppBase.BOLD + AppBase.DARK_TURQUOISE) \
            .__coloredMsg__(AppBase.ITALICS + AppBase.LIGHT_TURQUOISE) \
            .__tagMsg__(AppBase.LIGHT_GREEN,AppBase.LIGHT_TURQUOISE)
        self.prn("%s" % (self.__formattedMsg__()))
        return self

    def selfInstall(self, verbal = True):
        if self.isGlobal():
            if self.need_update():
                self.msg_old_global()
                if self.ask_update():
                    return self.download_and_install(verbal)
            else:
                self.msg_latest_global()
                return False
        elif self.isLocal():
            if self.need_update():
                self.msg_old_local()
                if self.ask_update():  
                    return self.download_and_install(verbal)
            else:
                self.msg_latest_local()
                return False
        elif self.installedGlobal():
            self.msg_global_already()
            if self.ask_overwrite_global():
                return self.__self_install__(this=self.thisFile(), verbal=verbal)
        elif self.installedLocal():
            self.msg_local_already()
            if self.ask_overwrite_local():  
                return self.install_local(verbal)
        elif self.username() != 'root':
            if self.ask_local():
                return self.install_local(verbal)
        else:
            return self.__self_install_globally__(verbal)

    def selfLocation(self):
        if self.thisFile() != '':
            return self.thisFile()
        try:
            shell = get_ipython().__class__.__name__
            if shell == 'ZMQInteractiveShell':
                return "Jupyter"
            elif shell == 'TerminalInteractiveShell':
                return "IPython"
            else:
                return "Unknown location"
        except NameError:
            return "Unknown location" 
        
    def selfUninstallGlobal(self, verbal = True):
        if self.installedGlobal():
            result = False
            display_once = False
            if self.username() != 'root':
                if self.sudo_test():
                    if self.targetApp() != '':
                        file1 = "%s/%s" % (self.globalFolder(0), self.targetApp())
                        file2 = "%s/%s" % (self.globalFolder(1), self.targetApp())
                        if os.path.exists(file1):
                            self.cmd_history('# ** Try to remove previous installed version **')
                            display_once = True
                            self.sudoRemoveFile(file1)
                        if os.path.exists(file1):
                            if not display_once:
                                self.cmd_history('# ** Try to remove previous installed version **')
                                display_once = True
                            self.sudoRemoveFile(file2)
                    if os.path.exists(self.globalInstallPath(0)):
                        if not display_once:
                            self.cmd_history('# ** Try to remove previous installed version **')
                            display_once = True
                        self.sudoRemoveFile(self.globalInstallPath(0))
                        result = True
                    if os.path.exists(self.globalInstallPath(1)):
                        if not display_once:
                            self.cmd_history('# ** Try to remove previous installed version **')
                            display_once = True
                        self.sudoRemoveFile(self.globalInstallPath(1))
                        result = True
                else:
                    if verbal:
                        self.msg_unintall_need_root()
                    return False
            else:
                if self.targetApp() != '':
                    file1 = "%s/%s" % (self.globalFolder(0), self.targetApp())
                    file2 = "%s/%s" % (self.globalFolder(1), self.targetApp())
                    if os.path.exists(file1):
                        self.cmd_history('# ** Try to remove previous installed version **')
                        display_once = True
                        self.sudoRemoveFile(file1)
                    if os.path.exists(file1):
                        if not display_once:
                            self.cmd_history('# ** Try to remove previous installed version **')
                            display_once = True
                        self.sudoRemoveFile(file2)
                if os.path.exists(self.globalInstallPath(0)):
                    if not display_once:
                        self.cmd_history('# ** Try to remove previous installed version **')
                        display_once = True
                    self.sudoRemoveFile(self.globalInstallPath(0))
                    result = True
                if os.path.exists(self.globalInstallPath(1)):
                    if not display_once:
                        self.cmd_history('# ** Try to remove previous installed version **')
                        display_once = True
                    self.sudoRemoveFile(self.globalInstallPath(1))
                    result = True
            if result:
                if verbal:
                    self.cmd_history_print()
                    self.msg_unintall_global()
            else:
                self.msg_global_failed()
            return result
        else:
            self.msg_no_global()
        return False

    def selfUninstall(self, verbal=True):
        once =False
        if self.installedLocal():
            self.selfUninstallLocal(verbal)
            once = True
        if self.installedGlobal():
            if once:
                self.selfUninstallGlobal(verbal=False)
            else:
                self.selfUninstallGlobal(verbal)
            once = True
        if not once:
            self.msg_no_installation()    

    def selfUninstallLocal(self, verbal = True):
        if self.installedLocal():
            self.cmd_history("# ** Try to remove previous installed version **")
            self.removeFile(self.localInstallPath())
            if not os.path.exists(self.localInstallPath()):
                if self.targetApp() != '':
                    self.removeFile(self.localTargetInstallPath())
                if verbal:
                    self.cmd_history_print()
                    self.msg_uninstall_local()
                return True
            else:
                self.msg_uninstall_local_failed()
                return False
        else:
            self.msg_no_local()
            return False

    def setInstallation(self,appName='',author='',lastUpdate='',homepage='',downloadUrl="",majorVersion=0,minorVersion=0):
        signal.signal(signal.SIGINT, self.signal_handler)
        self.checkSystem()
        self.author( author )
        self.appName( appName )
        self.downloadUrl( downloadUrl )
        self.homepage( homepage )
        self.lastUpdate( lastUpdate )
        self.majorVersion( majorVersion )
        self.minorVersion( minorVersion )

    def shell(self, command='', ignoreErr=False, ignoreShell=False, ignoreAll=False):
        stderr = ''
        stdout = ''
        useWinpty = False
        if ignoreAll:
            pipe_array=[]
        elif ignoreShell:
            if self.isGitBash():
                winpty = self.where_cmd('winpty.exe')
                if winpty == "":
                    pipe_array=[]
                else:
                    useWinpty = True
                    pipe_array=[winpty]
            else:
                pipe_array=[]
        elif self.isLinuxShell():   
            pipe_array=[self.shellCmd(),'-c']
        elif self.isGitBash():
            winpty = self.where_cmd('winpty.exe')
            if winpty == "":
                pipe_array=[self.shellCmd(),'-c']
            else:
                useWinpty = True
                pipe_array=[winpty, self.shellCmd(),'-c']
        elif self.isCmd():
            pipe_array=[self.shellCmd(),'/c']
        else:
            # Assume /bin/sh as default shell
            pipe_array=['/bin/sh','-c']
        if isinstance(command, basestring):
            pipe_array.append(command)
        elif isinstance(command, list):
            for cmdlet in command:
                pipe_array.append(cmdlet)
        else:
            if ignoreErr:
                return True, ""
            else:
                return False, "Wrong command data type."
        try:
            stdout,stderr = Popen(pipe_array,stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        except:
            if ignoreErr:
                return True
            else:
                return False
        if stderr.strip().lower() == 'stdin is not a tty' and useWinpty:
            stdout,stderr = Popen(pipe_array[1:],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        if stderr != "" and not ignoreErr:
            self.msg_error(command, stderr)
            return False, stderr
        else:
            return True, stdout

    def shellCmd(self, cmd=None):
        if cmd is not None:
            self.__shell_cmd__=cmd
            return self
        elif not hasattr(self,'__shell_cmd__'):
            if 'SHELL' in os.environ:
                self.__shell_cmd__ = os.environ['SHELL']
                # cannot use self.pathexists to avoid recursive call
            elif os.path.exists('/usr/bin/fish'):
                self.__shell_cmd__ = '/usr/bin/fish'
            elif os.path.exists('/bin/bash'):
                self.__shell_cmd__ = '/bin/bash'
            elif os.path.exists('/bin/ash'):
                self.__shell_cmd__ = '/bin/ash'
            elif os.path.exists('/bin/zsh'):
                self.__shell_cmd__ = '/bin/zsh'
            elif os.path.exists('/bin/sh'):
                self.__shell_cmd__ = '/bin/sh'
            elif os.path.exists('C:\\Windows\\System32\\cmd.exe'):
                self.__shell_cmd__ = 'C:\\Windows\\System32\\cmd.exe'
            else:
                self.__shell_cmd__=''
        return self.__shell_cmd__

    def signal_handler(self, sig, frame):
        self.prn('\nYou pressed Ctrl+C!')
        sys.exit(0)

    def sudo_test(self,msg='.'):
        distro = self.osVersion()
        if distro == 'windows':
            self.isSudo(False)
            return False
        if self.isSudo():
            return True
        if distro.startswith('Alpine'):
            stdout,stderr = Popen([ self.shellCmd(), '-c' , "which sudo" ],\
                stdin=PIPE,stdout=PIPE,stderr=PIPE,universal_newlines=True)\
                .communicate( '\n' )
            if stdout=='':
                return False
        stdout,stderr = Popen([ self.shellCmd(), '-c' , "sudo echo %s" % msg ],\
            stdin=PIPE,stdout=PIPE,stderr=PIPE,universal_newlines=True)\
            .communicate( '\n' )
        trial=0
        while stdout.strip() != msg.strip() and trial < 3:
            sudoPassword=getpass.getpass( 'Please input "sudo" password for %s: ' % self.username() )
            stdout, stderr = Popen([ self.shellCmd() , '-c',"sudo echo %s" % msg ] \
                ,stdin=PIPE,stdout=PIPE,stderr=PIPE,\
                universal_newlines=True ).communicate( "%s\n" % sudoPassword )
            trial=trial + 1
        if trial < 3:
            self.isSudo( True )
        return self.isSudo()

    def sudoRemoveFile(self, filePath):
        if os.path.exists(filePath):
            rm = self.which_cmd('rm')
            if self.username() == 'root':
                cmd = '%s -rf %s' % (rm, filePath)
            elif self.sudo_test():
                cmd = 'sudo %s -rf %s' % (rm, filePath)
            self.cmd_history(cmd)
            self.shell( cmd )

    def tag(self, tag=None):
        if tag is not None:
            self.__TAG__=tag
            return self
        elif not hasattr( self, '__TAG__' ):
            self.__TAG__=''
        return self.__TAG__

    def tar_extract(self,fname):
        if self.isCmd() or self.isGitBash():
            tar = self.where_cmd('tar.exe')
        else:
            tar = self.which_cmd('tar')
        cmd= [tar,"-xvf", fname]
        self.cmd_history(" ".join(cmd))
        result, stdout = self.shell(cmd,ignoreErr=True,ignoreAll=True)

    def targetApp(self, app=None):
        if app is not None:
            self.__target_app__=app
            return self
        elif not hasattr( self, '__target_app__' ):
            self.__target_app__=''
        return self.__target_app__

    def tempAppUrl(self):
        if self.downloadUrl()[-1] == '/':
            return "%s%s/%d.%d/%s.tar.gz" % (self.downloadUrl(), self.binaryVersion(), self.majorVersion(),self.minorVersion(), self.targetApp())
        else:
            return "%s/%s/%d.%d/%s.tar.gz" % (self.downloadUrl(), self.binaryVersion(), self.majorVersion(),self.minorVersion(), self.targetApp())

    def tempTargetGzip(self):
        timestamp = self.timestamp()
        if self.isLinuxShell():
            return "%s/%s-%s.tar.gz" % (self.tempFolder(), self.targetApp(), timestamp)
        elif self.isGitBash() or self.isCmd():
            return "%s\\%s-%s.tar.gz" % (self.tempFolder(), self.targetApp(), timestamp)
        return "%s/%s-%s.tar.gz" % (self.tempFolder(), self.targetApp(), timestamp)

    def tempAttachDecomp(self):
        if self.isCmd():
            fname="%s\\%s" % (self.tempFolder(),self.targetApp())
        elif self.isGitBash():
            fname="%s/%s" % (self.tempFolder(),self.targetApp())
        else:
            fname="%s/%s" % (self.tempFolder(), self.targetApp())
        return fname

    def tempFile(self):
        if self.isCmd():
            fname="%s\\%s-%s.bat" % (self.tempFolder(), self.appName(),self.timestamp())
        elif self.isGitBash():
            # GitBash download location should remain the same such that starting with /c/Users/user...
            fname="%s/%s-%s.bat" % (self.tempFolder(), self.appName(),self.timestamp())
        else:
            fname="%s/%s-%s" % (self.tempFolder(), self.appName(),self.timestamp())
        return fname

    def tempFolder(self):
        if self.isGitBash():
            folder="/C/Users/%s/AppData/Local/Temp" % self.username()
        elif 'TEMP' in os.environ:
            folder=os.environ['TEMP']
        elif self.isCmd():
            folder="C:\\Users\\%s\\AppData\\Local\\Temp" % self.username()
        elif self.username() == 'root':
            folder="/tmp" 
        elif self.osVersion() == 'macOS':
            folder = '/Users/%s/Library/Caches' % self.username()
        else:
            folder="/home/%s/.local/temp" % self.username()
            self.mkdir(folder)
        return folder

    def this(self, this = None):
        if this is None :
            if not hasattr(self, '__this__'):
                self.__this__=self.appPath()
            return self.__this__
        else:
            self.__this__ = this
            return self

    @staticmethod
    def thisFile():
        return AppBase.__here__

    def timestamp(self):
        return "%s" % (int(time.time()))

    def where_cmd(self, cmd):
        stdout = ''
        if self.isLinuxShell():
            return self.which_cmd(cmd)
        elif self.isCmd()  or self.isGitBash():
            path = "C:\\Users\\%s\\AppData\\Local\\Microsoft\\WindowsApps\\%s" % (self.username(), cmd)
            if os.path.exists('C:\\Windows\\system32\\%s' % cmd):
                return 'C:\\Windows\\system32\\%s' % cmd
            elif os.path.exists(path):
                return path
            elif 'PATH' in os.environ:
                split_path = os.environ['PATH'].split(';')
                for pathlet in split_path:
                    if os.path.exists('%s\\%s' % (pathlet, cmd)):
                        return '%s\\%s' % (pathlet, cmd)
        return cmd

    def which(self):
        if self.isCmd()  or self.isGitBash():
            if self.pathexists(self.localInstallPath()):
                return self.localInstallPath()
            elif self.pathexists(self.globalInstallPath(0)):
                return self.globalInstallPath(0)
            elif self.pathexists(self.globalInstallPath(1)):
                return self.globalInstallPath(1)
            elif self.pathexists('C:\\Windows\\System32\\where.exe'):
                return self.where_cmd( self.appName())
        else:
            if self.pathexists(self.localInstallPath()):
                return self.localInstallPath()
            elif self.pathexists(self.globalInstallPath(0)):
                return self.globalInstallPath(0)
            elif self.pathexists(self.globalInstallPath(1)):
                return self.globalInstallPath(1)
            if self.pathexists('/usr/bin/which'):
                return self.which_cmd( self.appName())

    def which_cmd(self, cmd):
        stdout = ''
        if self.isCmd() or self.isGitBash():
            return self.where_cmd(cmd)
        elif self.isLinuxShell():
            if os.path.exists('/bin/%s' % cmd):
                return '/bin/%s' % cmd
            elif os.path.exists('/usr/bin/%s' % cmd):
                return '/usr/bin/%s' % cmd
            elif os.path.exists('/usr/bin/local/%s' % cmd):
                return '/usr/bin/local/%s' % cmd
            elif os.path.exists('/home/%s/.local/bin/%s' % (self.username(), cmd)):
                return '/home/%s/.local/bin/%s' % (self.username(), cmd)
            elif os.path.exists('/usr/bin/which'):
                result, stdout = self.shell("/usr/bin/which %s" % cmd, ignoreErr=True)
                return stdout.strip()
            elif os.path.exists('/bin/which'):
                result, stdout = self.shell("/usr/bin/which %s" % cmd, ignoreErr=True)
                return stdout.strip()
            elif 'PATH' in os.environ:
                split_path = os.environ['PATH'].split(':')
                for pathlet in split_path:
                    if os.path.exists('%s/%s' % (pathlet, cmd)):
                        return '%s/%s' % (pathlet, cmd)
        return cmd

    def uname(self, switch, ignoreErr=True):
        stderr = ''
        stdout = ''
        command = 'uname %s' % switch
        if self.isLinuxShell():
            uname = self.which_cmd('uname')
            stdout,stderr = Popen([uname,switch],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        if self.isGitBash():
            winpty = self.where_cmd('winpty.exe')
            uname = self.where_cmd('uname.exe')
            stdout,stderr = Popen([winpty, uname,switch],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
            if stderr.strip().lower() == 'stdin is not a tty':
                stdout,stderr = Popen([uname,switch],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        elif self.isCmd():
            stdout,stderr = Popen([self.shellCmd(),'/c',command],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        else:
            # Assume /bin/sh as default shell
            uname = self.which_cmd('uname')
            stdout,stderr = Popen([uname,switch],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        if stderr != "" and not ignoreErr:
            self.msg_error(command, stderr)
            return False, stderr
        else:
            return True, stdout

    def uname_a(self, ignoreErr=True):
        return self.uname('-a')

    def uname_m(self, ignoreErr=True):
        return self.uname('-m')

    def useColor(self, color=None):
        if color is not None:
            self.__useColor__=color
            return self
        elif not hasattr(self, '__useColor__'):
            if self.isGitBash():
                # Gitbash cannot show color
                self.__useColor__=False
            else:
                self.__useColor__=True
        return self.__useColor__

    def userID(self):
        return os.getuid()

    def username(self):
        if pwd is None:
            return os.getlogin()
        return pwd.getpwuid(self.userID())[0]

    def version(self):
        return "%s.%s" % (self.majorVersion(),self.minorVersion())

    def zshenv(self):
        return os.path.join(self.home(), ".zshenv")

    def ask_local(self):
        return 'yes' == self.__ask_yesno__('Do you want to install locally? (yes/no) ')

    def ask_overwrite_global(self):
        return 'yes' == self.__ask_yesno__('Do you want to overwrite the global installation? (yes/no) ')

    def ask_overwrite_local(self):
        return 'yes' == self.__ask_yesno__('Do you want to overwrite the local installation? (yes/no) ')

    def ask_update(self):
        return 'yes' == self.__ask_yesno__('Do you want to update the latest (%s) from internet? (yes/no) ' % self.latest_version())

    def msg_alpine_detected(self, title="OPERATION SYSTEM"):
        self.infoMsg("Alpine Detected!", title)

    def msg_both_local_global(self, title="INSTALLED TWICE"):
        self.criticalMsg("It may causes error if you have installed both local version and Global Version!\n  Please uninstall local version by,\n    %s uninstall" % self.appPath(), title)

    def msg_download_error(self, file):
        if not hasattr(self,'__msgshown_download_error__'):
            self.criticalMsg("Download file error: %s" % file, "DOWNLOAD ERROR")
            self.__msgshown_download_error__=True

    def msg_download_url_error(self, url, code):
        if not hasattr(self,'__msgshown_download_error__'):
            self.criticalMsg("Url: %s\n  HTTP code: %s" % (url, code), "DOWNLOAD ERROR")
            self.__msgshown_download_error__=True

    def msg_download_not_found(self, file):
        self.criticalMsg("Downloaded File: %s" % file, "NOT FOUND")

    def msg_downloaded(self, fname="", title="DOWNLOADED"):
        self.safeMsg("File downloaded to: %s" % fname, title)

    def msg_downloading(self, url="", title="DOWNLOAD FILES"):
        self.infoMsg("Downloading: %s ..." % url, title)

    def msg_error(self, command="", stderr="", title="ERROR"):
        self.criticalMsg("Error in %s: %s" % (command, stderr), title)

    def msg_extraction_error(self, file="", title="DOWNLOAD ERROR"):
        self.criticalMsg("File Extraction error: %s not found" % file, title)

    def msg_global_already(self, title="SELF INSTALL"):
        self.infoMsg("Global Installation installed already!", title)

    def msg_global_failed(self, title="SELF INSTALL"):
        self.criticalMsg("Global uninstall failed!", title)

    def msg_info(self, usage=""):
        if self.isCmd():
            msg1="%s.bat (%s.%s) by %s on %s" % (self.appName(),self.majorVersion(),\
                self.minorVersion(),self.author(),self.lastUpdate())
        else:
            msg1="%s (%s.%s) by %s on %s" % (self.appName(),self.majorVersion(),\
                self.minorVersion(),self.author(),self.lastUpdate())
        if self.isGlobal():
            app = "You are using the GLOBAL INSTALLED version, location:"
        elif self.isLocal():
            app = "You are using the LOCAL INSTALLED version, location:"
        else :
            app = "You are using an UNINSTALLED version, location:" 
        arch = self.arch()
        python_exe = self.executable()
        if python_exe == '':
            python_exe = self.pythonName()
        msg = [
            msg1, 
            "Python %s" % self.pythonVersion(),
            "Shell: %s" % self.shellCmd(),
            "Operation System: %s %s" % (self.osVersion(), self.libcVersion() ), 
            "Architecture: %s" % arch,
            '',
            '%s' % app,
            '    %s' % self.selfLocation(),
            '', 
            "Basic Usage:",
            "    %s" % usage,
            '',
            'Please visit our homepage: ',
            '    "%s"' % self.homepage(),
            '',
            'Installation command:',
            '    curl -fsSL %s|%s' % (self.downloadUrl(), python_exe),
            ''
        ]
        starLine=[]
        space=[]
        spaces=[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
        if self.targetApp() != '':
            spaces.append([])
            spaces.append([])
            msg.append('Target Application:')
            if self.isCmd() or self.isGitBash():
                file3 = self.localTargetInstallPath()
                if os.path.exists(file3):
                    msg.append('    %s' % file3)
                    spaces.append([])
            else:
                file1 = "%s/%s" % (self.globalFolder(0), self.targetApp())
                file2 = "%s/%s" % (self.globalFolder(1), self.targetApp())
                file3 = self.localTargetInstallPath()
                if os.path.exists(file1):
                    msg.append('    %s' % file1)
                    spaces.append([])
                if os.path.exists(file2):
                    msg.append('    %s' % file2)
                    spaces.append([])
                if os.path.exists(file3):
                    msg.append('    %s' % file3)
                    spaces.append([])
            msg.append('')
        maxLen=len(msg[0])
        if self.downloadUrl() == '':
            if self.homepage() == '':
                max_line = len(spaces) - 3
            else:
                max_line = len(spaces) - 2
        else:
            max_line = len(spaces) - 1
        for n in range(1, max_line):
            if len(msg[n]) > maxLen :
                maxLen=len(msg[n])
        for n in range(0, max_line):
            for i in range(1,maxLen - len(msg[n]) + 1):
                spaces[n].append(' ')
            msg[n]=msg[n] + ''.join(spaces[n])
        for i in range(1,maxLen + 5):
            starLine.append("*")
        for i in range(1,maxLen + 1):
            space.append(" ")
        self.prn(''.join(starLine))
        self.prn('* %s *' % ''.join(space))
        for n in range(0, max_line):
            self.prn('* %s *' % msg[n])
        self.prn('* %s *' % ''.join(space))
        self.prn(''.join(starLine))

    def msg_install_app_global(self, title="INSTALL"):
        if self.isCmd() or self.isGitBash():
            self.msg_install(location='Globally', app="%s.bat" % self.appName(), title=title)
        else:
            self.msg_install(location='Globally', app=self.appName(), title=title)

    def msg_install_app_local(self, title="INSTALL"):
        if self.isCmd() or self.isGitBash():
            self.msg_install(location='Locally', app="%s.bat" % self.appName(), title=title)
        else:
            self.msg_install(location='Locally', app=self.appName(), title=title)

    def msg_install(self, location="", app="", title="INSTALL"):
        startSh =  ""   # for ash, cmd, gitbash
        if location == 'Locally':
            if self.osVersion() == 'macOS':
                startSh = "  Please type 'hash -r' and 'source ~/.zshenv' to refresh zsh shell hash!\n  Then, you can "
            elif self.shellCmd() != '/bin/ash' and self.isLinuxShell():
                startSh =  "  Please type 'hash -r' and 'source ~/.bashrc' to refresh bash shell hash!\n  Then, you can "
            self.safeMsg("Installed %s! \n%s  type '%s' to run!" % (location, startSh, app), title)
        else:
            self.safeMsg("Installed %s! \n    type '%s' to run!" % (location, app), title)

    def msg_install_target_global(self, title="INSTALL"):
        if self.isCmd() or self.isGitBash():
            self.msg_install(location='Globally', app="%s.exe" % self.targetApp(), title=title)
        else:
            self.msg_install(location='Globally', app=self.targetApp(), title=title)

    def msg_install_target_local(self, title="INSTALL"):
        if self.isCmd() or self.isGitBash():
            self.msg_install(location='Locally', app="%s.exe" % self.targetApp(), title=title)
        else:
            self.msg_install(location='Locally', app=self.targetApp(), title=title)

    def msg_latest(self, title="CHECK VERSION"):
        if self.isLocal():
            self.msg_latest_global(title)
        elif self.isLocal():
            self.msg_latest_local(title)
        else:
            self.infoMsg("You are using latest (%s.%s) already!" % (self.majorVersion(),self.minorVersion()), title)

    def msg_latest_global(self, title="CHECK VERSION"):
        self.infoMsg("You are using latest (%s.%s) Global Installation's copy already!" % (self.majorVersion(),self.minorVersion()), title)

    def msg_latest_local(self, title="CHECK VERSION"):
        self.infoMsg("You are using latest (%s.%s) Local Installation's copy already!" % (self.majorVersion(),self.minorVersion()), title)

    def msg_latest_available(self, title="CHECK UPDATE"):
        self.infoMsg("Latest Version = %s\n  Update is available" % self.latest_version(), title)

    def msg_local_already(self, title="SELF INSTALL"):
        self.infoMsg("Local Installation installed already!", title)

    def msg_no_global(self, title="GLOBAL UNINSTALL"):
        self.infoMsg("You don't have any local installation.", title)

    def msg_no_local(self, title="LOCAL UNINSTALL"):
        self.infoMsg("You don't have any local installation.", title)

    def msg_no_server(self, title="CONNECTION FAILED"):
        self.criticalMsg("Cannot communicate with server", title)

    def msg_no_installation(self, title="UNINSTALL"):
        self.infoMsg("You don't have any global or local installation.", title)

    def msg_root_continue(self, title="SELF INSTALL"):
        self.criticalMsg("You must be root to continue installation!", title)

    def msg_old_global(self, title="SELF INSTALL"):
        self.infoMsg("You are using an old (%s.%s) Global Installation's copy already!" % (self.majorVersion(),self.minorVersion()), title)

    def msg_old_local(self, title="SELF INSTALL"):
        self.infoMsg("You are using an old (%s.%s) Local Installation's copy already!" % (self.majorVersion(),self.minorVersion()), title)

    def msg_sudo_failed(self, title="SUDO FAILED"):
        self.criticalMsg("You should be root or sudo to install globally.", title)

    def msg_system_check(self, title="START"):
        if not hasattr(self,'__system_msg_shown__'):
            self.safeMsg("Now checking your operation system!", title)
            self.prn("    Python: %s" % self.pythonVersion())
            self.prn("    C Library: %s" % self.libcVersion())
            self.prn("    Operation System: %s" % self.osVersion())
            self.prn("    Current User: %s" % self.username())
            self.prn("    Shell: %s" % self.shellCmd())
            self.prn("    Python Executable: %s" % self.executable())
            self.prn("    Binary Type: %s" % self.binaryVersion() )
            self.prn("")
            self.__system_msg_shown__ = True

    def msg_timeout(self, file="", title="ERROR"):
        self.criticalMsg("Time out in downloading %s" % (file), title)

    def msg_unintall_global(self, title="GLOBAL UNINSTALL"):
        self.safeMsg("You have uninstalled successfully.", title)

    def msg_uninstall_global_failed(self, title="UNINSTALL FAILED"):
        self.criticalMsg("Failed to uninstall globally", title)

    def msg_uninstall_local(self, title="LOCAL UNINSTALL"):
        self.safeMsg("You have uninstalled successfully.", title)

    def msg_uninstall_local_failed(self, title="UNINSTALL FAILED"):
        self.criticalMsg("Failed to uninstall locally", title)

    def msg_unintall_need_root(self, title="GLOBAL UNINSTALL"):
        self.criticalMsg("You should be root or sudo to uninstall globally.", title)

class OnlineInstaller(AppBase):

    def start(self):
        self.allowInstallLocal(True)
        usage = "%s [check-update|install|uninstall]" % self.appExec()
        if not self.parseArgs(usage):
            self.msg_info(usage)

if __name__ == "__main__":
    app = OnlineInstaller()
    app.targetApp('spanish-num')
    app.setInstallation(appName='spanish-num-installer',author='Cloudgen Wong',homepage="https://github.com/cloudgen2/spanish-num",downloadUrl="https://dl.leolio.page/spanish-num",lastUpdate='2023-10-14',majorVersion=0,minorVersion=4)
    app.start() 
