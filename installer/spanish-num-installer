#!/bin/sh
# -*- coding: utf-8 -*-
""":"
_PY_=$(which python3); if [ -z $_PY_ ]; then _PY_=$(which python2); if [ -z $_PY_ ]; then _PY_=$(which pypy3); if [ -z $_PY_ ]; then _PY_=$(which pypy); if [ -z $_PY_ ]; then exit 1; fi; fi; fi; fi; exec $_PY_ "$0" "$@"
":"""

from __future__ import print_function
try:
    raw_input
except NameError:
    raw_input = input
try:
    basestring
except NameError:
    basestring = str
try: 
    __file__
except NameError: 
    __file__ = None

from datetime import datetime
import getpass
import os
import pwd
import re
import signal
from subprocess import Popen, PIPE
import subprocess
import shutil
import socket
import time
import sys

class AppBase(object):

    BOLD='\033[1m'
    DARK_AMBER='\033[33m'
    DARK_BLUE='\033[34m'
    DARK_TURQUOISE='\033[36m'
    END='\033[0m'
    FLASHING='\033[5m'
    ITALICS='\033[3m'
    LIGHT_RED='\033[91m'
    LIGHT_AMBER='\033[93m'
    LIGHT_BLUE='\033[94m'
    LIGHT_GREEN='\033[92m'
    LIGHT_TURQUOISE='\033[96m'

    __here__ = __file__

    def __alpine_ask_install_sudo__(self):
        if 'yes' == self.__ask_yesno__('Do you want to install sudo? (yes/no) '):
            r
            esult, stdout = self.shell("apk add sudo", True)
            result, stdout = self.shell("echo '%wheel ALL=(ALL) ALL' > /etc/sudoers.d/wheel")

    def __ask_yesno__(self, ask):
        if not hasattr(self, '__regex_yesno__'):
            self.__regex_yesno__ = re.compile(r"yes|no")
        ask_yesno = raw_input(ask).strip().lower()
        while ask_yesno == '' or self.__regex_yesno__.sub("",ask_yesno) != '':
            ask_yesno = raw_input(ask).strip().lower()
        return ask_yesno

    def __coloredMsg__(self,color=None):
        if color is None :
            if self.__message__() == '':
                return ''
            else:
                return "%s%s%s" % (self.__colorMsgColor__(),\
                    self.__message__(),self.__colorMsgTerm__())
        else:
            if color == '' or not self.useColor():
                self.__colorMsgColor__('')
                self.__colorMsgTerm__('')
            else:
                self.__colorMsgColor__(color)
                self.__colorMsgTerm__(AppBase.END)
            return self

    def __colorMsgColor__(self, color=None):
        if color is not None:
            self.__cmc__=color
            return self
        elif not hasattr(self,'__cmc__'):
            self.__cmc__=""
        return self.__cmc__

    def __colorMsgTerm__(self,term=None):
        if term is not None:
            self.__cmt__=term
            return self
        elif not hasattr(self,'__cmt__'):
            self.__cmt__=""
        return self.__cmt__

    def __current_path__(self, x):
        return "%s/%s" % (os.getcwd(),x)

    def __formattedMsg__(self):
        return "%s %s %s\n  %s" % (self.__timeMsg__(),self.__header__(),\
            self.__tagMsg__(),self.__coloredMsg__())

    def __header__(self,color=None):
        if color is None:
            return "%s%s(v%s) %s" % (self.__headerColor__(),\
                self.appName(),self.version(),\
                self.__headerTerm__())
        else:
            if color == '' or not self.useColor():
                self.__headerColor__('')\
                    .__headerTerm__('')
            else:
                self.__headerColor__(color)\
                    .__headerTerm__(AppBase.END)
        return self

    def __headerColor__(self,color=None):
        if color is not None:
            self.__hc__=color
            return self
        elif not hasattr(self,'__hc__'):
            self.__hc__=""
        return self.__hc__

    def __headerTerm__(self,term=None):
        if term is not None:
            self.__ht__=term
            return self
        elif not hasattr(self,'__ht__'):
            self.__ht__=""
        return self.__ht__

    def __install_local__(self, this = None, verbal = True ):
        if this is None:
            this = self.this()
        result, stdout = self.shell("mkdir -p %s" % self.localInstallFolder())
        result, stdout = self.shell("rm -rf %s" % self.localInstallPath())
        result, stdout = self.shell("cp %s %s" % ( this, self.localInstallPath()))
        result, stdout = self.shell("chmod +x %s" % self.localInstallPath())
        startSh =  ""
        if self.osVersion() == 'macOS':
            self.check_and_modify_zshenv()
            startSh = " and 'source ~/.zshenv'"
        elif self.osVersion() != 'Alpine' :
            self.check_and_modify_bashrc()
            startSh =  " and 'source ~/.bashrc'"
        if result and verbal:
            self.safeMsg("Installed Locally! \n  Your OS is: %s\n  Please type 'hash -r'%s to refresh bash shell hash!\n  Then, you can type '%s' to run!" 
                % (self.osVersion(), startSh, self.appName()), "SELF INSTALL")
        return result

    def __message__(self,message=None):
        if message is not None:
            self.__m__=message
            return self
        elif not hasattr(self,'__m__'):
            self.__m__=""
        return self.__m__

    def __self_install__(self, this=None, verbal = True):
        if this is None:
            this = self.this()
        result = False
        try_global = True
        if self.username() != 'root':
            if self.allowInstallLocal():
                if self.__ask_yesno__('You are not using root account. Do you want to continue? (yes/no) ') == 'yes':
                    if self.__ask_yesno__('Install globally (yes) or locally(no)? (yes/no) ') == 'no':
                        try_global = False
                        result = self.__install_local__()
            elif self.__ask_yesno__('You are not using root account. Do you want to continue? (yes/no) ') == 'no':
                try_global = False
                result = False
                if try_global:
                    if self.osVersion() == 'Alpine':
                        self.infoMsg("Alpine Detected!", "OPERATION SYSTEM")
                        self.criticalMsg("You should be root or sudo to install globally.", "SUDO FAILED")
                        result = False
                    elif self.sudo_test():
                        result, stdout = self.shell("sudo cp %s %s" % (this, self.globalInstallPath()))
                        result, stdout = self.shell("sudo chmod +x %s" % self.globalInstallPath())
                    else:
                        self.criticalMsg("You should be root or sudo to install globally.", "SUDO FAILED")
                        result = False
        else:
            result, stdout = self.shell("cp %s %s" % ( this, self.globalInstallPath()))
            result, stdout = self.shell("chmod +x %s" % self.globalInstallPath())
        if result:
            if try_global and verbal:
                self.safeMsg("Installed Globally! \n  Please type 'hash -r' to refresh bash shell hash!\n  Then, you can type '%s' to run!" % self.appName(), "SELF INSTALL")
        return result

    def __self_install_globally__(self, verbal = True):
        if self.sudo_test():
            return self.__self_install__(self.this(), verbal)
        elif self.username() != 'root':
            self.criticalMsg("You must be root to continue installation!", "SELF INSTALL")
            return False
        else:
            return self.__self_install__(self.this(), verbal)

    def __tag__(self, tag=None):
        if tag is not None:
            self.__t__=tag
            return self
        elif not hasattr(self,'__t__'):
            self.__t__=''
        return self.__t__

    def __tagColor__(self, color=None):
        if color is not None:
            self.__tc__=color
            return self
        elif not hasattr(self,'__tc__'):
            self.__tc__=''
        return self.__tc__

    def __tagMsg__(self,color=None,outterColor=None):
        if color is None:
            if self.__tag__() == '' or not self.useColor():
                return ': '
            else:
                return "%s[%s%s%s%s%s]:%s " % (self.__tagOutterColor__(),\
                    self.__tagTerm__(),self.__tagColor__(),\
                    self.__tag__(),self.__tagTerm__(),\
                    self.__tagOutterColor__(),self.__tagTerm__())
        else:
            if color == '':
                self.__tagColor__('')\
                    .__tagOutterColor__('')\
                    .__tagTerm__('')
            else:
                self.__tagColor__(color)\
                    .__tagOutterColor__(outterColor)\
                    .__tagTerm__(AppBase.END)
            return self

    def __tagOutterColor__(self, color=None):
        if color is not None:
            self.__toc__=color
            return self
        elif not hasattr(self,'__toc__'):
            self.__toc__=''
        return self.__toc__
    
    def __tagTerm__(self, term=None):
        if term is not None:
            self.__tt__=term
            return self
        elif not hasattr(self,'__tt__'):
            self.__tt__=''
        return self.__tt__

    def __timeColor__(self, color=None):
        if color is not None:
            self.__tcolor__=color
            return self
        elif not hasattr(self,'__tcolor__'):
            self.__tcolor__=''
        return self.__tcolor__

    def __timeMsg__(self, color=None):
        if color is None:
            return "%s%s%s" % (self.__timeColor__(),self.now(),\
                self.__timeTerm__())
        else:
            if color == '' or not self.useColor():
                self.__timeColor__('')\
                    .__timeTerm__('')
            else:
                self.__timeColor__(color)\
                    .__timeTerm__(AppBase.END)
            return self

    def __timeTerm__(self, term=None):
        if term is not None:
            self.__tterm__=term
            return self
        elif not hasattr(self,'__tterm__'):
            self.__tterm__=''
        return self.__tterm__

    def add_bashrc_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "# modified to add ~/.local/bin to PATH",
            "PATH=$PATH:~/.local/bin\n"
        ]
        
        with open(self.bashrc(), "a") as file:
            file.write("\n".join(modification_lines))

    def add_zshenv_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "\n# modified to add ~/.local/bin to PATH",
            "path+=('%s')" %  os.path.join(self.home(), ".local/bin"),
            "export PATH\n"
        ]
        with open(self.zshenv(), "a") as file:
            file.write("\n".join(modification_lines))

    def allowInstallLocal(self, installLocal=None):
        if installLocal is not None:
            self.__allowInstallLocal__=installLocal
            return self
        elif not hasattr(self,'__allowInstallLocal__'):
            self.__allowInstallLocal__=False
        return self.__allowInstallLocal__

    def appPath(self, path=None):
        if path is not None:
            self.__appPath__=path
            return self
        elif not hasattr(self,'__appPath__'):
            self.__appPath__=''
        return self.__appPath__

    def assist_install_requests(self):
        self.criticalMsg("Cannot find module: requests. \n  Please try to fix by installing the followings:", "MODULE NOT FOUND")
        if self.osVersion() == "macOS":
            if self.pythonName() == "python3":
                self.print("    pip3 install urllib3==1.26.6")
                self.print("    pip3 install requests")
            elif self.pythonName() == "python2":
                self.print("    pip install urllib3==1.26.6")
                self.print("    pip install requests")
            elif self.pythonName() == "pypy3":
                self.print("    find /usr/local/lib/pypy3.10 -type f -name '*.so' -exec sudo xattr -r -d com.apple.quarantine {} \;")
                self.print("    sudo pypy3 -m ensurepip")
                self.print("    sudo pypy3 -m pip install urllib3==1.26.6")
                self.print("    sudo pypy3 -m pip install requests")
        else:
            if self.pythonName() == "python3":
                if ('Ubuntu' in self.osVersion() or 'Debian' in self.osVersion() ) and self.pythonMinor() > 10:
                    if self.username() == 'root':
                        self.print("    apt install python3-requests")
                    else:
                        self.print("    python3 -m pipx install requests")
                else:
                    if self.username() == 'root':
                        self.print("    apt install -y python3-pip")
                        self.print("    pip3 install requests")
                    else:
                        self.print("    python3 -m pip install requests")
            elif self.pythonName() == "python2":
                if self.username() == 'root':
                    self.print("    apt install -y python-pip")
                    self.print("    pip install requests")
                else:
                    self.print("    pypy -m pip install requests")
            elif self.pythonName() == "pypy3":
                if self.username() == 'root':
                    if ('Ubuntu' in self.osVersion() or 'Debian' in self.osVersion() ) and self.pythonMinor() > 10:
                        self.print("    apt install -y pypy3-request")
                    else:
                        self.print("    pypy3 -m ensurepip")
                        self.print("    pypy3 -m pip install requests")
                else:
                    self.print("    pypy3 -m pip install requests")

    def arch(self):
        if not hasattr(self, '__arch__'):
            result2, stdout2 = self.shell("uname -a")
            result, stdout = self.shell("uname -m")
            if result:
                self.__arch__ = stdout.strip()
                if self.__arch__ == 'arm64':
                    self.__arch__ = 'aarch64'
                elif 'ARM64' in stdout2:
                    self.__arch__ = 'aarch64'
                elif self.__arch__ == 'x86_64':
                    self.__arch__ = 'amd64'
            else:
                self.__arch__=''
        return self.__arch__

    def author(self, author=None):
        if author is not None:
            self.__author__=author
            return self
        elif not hasattr(self,'__author__'):
            self.__author__=None
        return self.__author__

    def appName(self, appName=None):
        if appName is not None:
            self.__appName__=appName
            return self
        elif not hasattr(self,'__appName__'):
            self.__appName__=''
        return self.__appName__

    def bashrc(self):
        return os.path.join(self.home(), ".bashrc")

    def check_and_modify_bashrc(self):
        if not self.is_bashrc_modified():
            self.add_bashrc_modification()

    def check_and_modify_zshenv(self):
        if not self.is_zshenv_modified():
            self.add_zshenv_modification()

    def checkSystem(self):
        if self.pythonVersion().split(".")[0] =="3":
            self.pythonName( "python3" )
            major = 3
        else:
            self.pythonName( "python2" )
            major = 2
        minor = int(self.pythonVersion().split(".")[0])
        gcc = sys.version
        if '\n' in gcc:
            gcc = gcc.split('\n')[1]
        elif '[' in gcc and ']' in gcc:
            gcc = gcc.split('[')[1].split(']')[0]
        if gcc=='GCC':
            gcc= '[GCC]'
        if ' (Red Hat' in gcc:
            gcc = gcc.split(' (Red Hat')[0] + ']'
        if '[PyPy ' in gcc and 'with' in gcc:
            pythonVersion = gcc.split('with')[0].split('[')[1]
            self.pythonVersion("%s (%s)" % (self.pythonVersion(), pythonVersion))
            gcc = '[' + gcc.split('with ')[1]
            if self.pythonName() == "python3":
                self.pythonName( "pypy3")
            else:
                self.pythonName( "pypy" )
        self.gccVersion(gcc)

    def cmd(self, cmd=None):
        if cmd is not None:
            self.__cmd__=cmd
            return self
        elif not hasattr(self, '__cmd__'):
            self.__cmd__=False
        return self.__cmd__

    def cmdList(self, x=None, rstrip=False):
        if not hasattr(self,'__cmdList__'):
            self.__cmdList__=[]
        if x is not None:
            if isinstance(x,list):
                for l in x:
                    if isinstance(l,basestring) and rstrip:
                        self.__cmdList__.append(l.rstrip())
                    else:
                        self.__cmdList__.append(l)
            else:
                self.__cmdList__.append(x)
            return self
        return self.__cmdList__

    def comparePath(self, p1, p2):
        return os.path.abspath(p1)==os.path.abspath(p2)

    def criticalMsg(self,msg,tag=''):
        self.__tag__(tag).__message__(msg) \
            .__timeMsg__(AppBase.BOLD + AppBase.ITALICS + \
            AppBase.DARK_AMBER) \
            .__header__(AppBase.BOLD + AppBase.DARK_AMBER) \
            .__coloredMsg__(AppBase.ITALICS + AppBase.LIGHT_AMBER) \
            .__tagMsg__(AppBase.FLASHING + AppBase.LIGHT_RED,\
            AppBase.LIGHT_AMBER)
        self.print("%s" % (self.__formattedMsg__()))
        return self

    def curPath(self, curPath=None):
        if curPath is not None:
            self.__curPath__=curPath
            return self
        elif not hasattr(self, '__curPath__'):
            self.__curPath__=os.getcwd()
        return self.__curPath__

    def download_and_install(self, verbal = True):
        self.safeMsg("Now checking your operation system!", "START")
        self.checkSystem()
        self.print("    Python: %s" % self.pythonVersion())
        self.print("    GCC: %s" % self.gccVersion())
        self.print("    Operation System: %s" % self.osVersion())
        self.print("    Current User: %s" % self.username())
        self.print("")
        fname="/tmp/%s-%s" % (self.appName(),self.timestamp())
        try:
            import requests
            self.print("    ... Downloading %s ..." % self.downloadUrl())
            req=requests.get(self.downloadUrl())
            if str(req.status_code) == '200':
                fp=open(fname,"w")
                fp.write(req.content.decode('utf8'))
                fp.close()
                self.this(fname)
                if self.username() == 'root':
                    return self.__self_install__(fname, verbal)
                else:
                    return self.__install_local__(fname, verbal)
            else:
                self.criticalMsg("Failed to download!","DONWLOAD FAILED")
                return False
        except:
            result, stdout = self.shell("curl -fsSL -o %s %s" % (fname, self.downloadUrl()), True)
            if result:
                self.this(fname)
                if self.username() == 'root':
                    return self.__self_install__(fname, verbal)
                else:
                    return self.__install_local__(fname, verbal)
        return False

    def downloadHost(self):
        if self.downloadUrl() == '':
            return ''
        x = re.search("https:\/\/([^\/]+)", self.downloadUrl())
        if x:
            return x.group(1)
        else:
            ''

    def downloadUrl(self, downloadUrl=None):
        if downloadUrl is not None:
            self.__downloadUrl__=downloadUrl
            return self
        elif not hasattr(self,'__downloadUrl__'):
            self.__downloadUrl__=None
        return self.__downloadUrl__

    def duplication_warning(self):
        if self.installedLocal() and self.installedGlobal():
            self.criticalMsg("It may causes error if you have installed both local version and Global Version!\n  Please uninstall local version by,\n    %s uninstall" % self.appPath(), "INSTALLED TWICE")

    def gccVersion(self, version=None):
        if version is not None:
            self.__gcc_version__ = version
            return self
        elif not hasattr(self, '__gcc_version__'):
            self.__gcc_version__ = ''
        return self.__gcc_version__

    def globalInstallPath(self):
        return '%s%s' % (self.globalInstallRoot(), self.appName())

    def globalInstallRoot(self, path=None):
        if path is not None:
            self.__globalInstallRoot__=path
            return self
        elif not hasattr(self,'__globalInstallRoot__'):
            self.__globalInstallRoot__='/usr/local/bin/'
        return self.__globalInstallRoot__

    def hasGlobalInstallation(self):
        return  os.path.exists(self.globalInstallPath())

    def home(self):
        return os.path.expanduser("~")

    def homepage(self, homepage=None):
        if homepage is not None:
            self.__homepage__=homepage
            return self
        elif not hasattr(self,'__homepage__'):
            self.__homepage__=None
        return self.__homepage__

    def info(self, usage=""):
        self.checkSystem()
        msg1="%s (%s.%s) by %s on %s" % (self.appName(),self.majorVersion(),\
            self.minorVersion(),self.author(),self.lastUpdate())
        if self.isGlobal():
            app = "You are using the GLOBAL INSTALLED version, location:"
        elif self.isLocal():
            app = "You are using the LOCAL INSTALLED version, location:"
        else :
            app = "You are using an UNINSTALLED version, location:" 
        arch = self.arch()
        msg = [
            msg1, 
            "Python %s" % self.pythonVersion(),
            "Operation System: %s %s" % (self.osVersion(), self.gccVersion() ), 
            "Architecture: %s" % arch,
            '',
            '%s' % app,
            '    %s' % self.selfLocation(),
            '', 
            "Basic Usage:",
            "    %s" % usage,
            '',
            'Please visit our homepage: ',
            '    "%s"' % self.homepage(),
            '',
            'Installation command:',
            '    curl -fsSL %s | %s' % (self.downloadUrl(), self.pythonName()),
            ''
        ]
        starLine=[]
        space=[]
        spaces=[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
        maxLen=len(msg[0])
        if self.downloadUrl() == '':
            if self.homepage() == '':
                max_line = 10
            else:
                max_line = 13
        else:
            max_line = 16
        for n in range(1, max_line):
            if len(msg[n]) > maxLen :
                maxLen=len(msg[n])
        for n in range(0, max_line):
            for i in range(1,maxLen - len(msg[n]) + 1):
                spaces[n].append(' ')
            msg[n]=msg[n] + ''.join(spaces[n])
        for i in range(1,maxLen + 5):
            starLine.append("*")
        for i in range(1,maxLen + 1):
            space.append(" ")
        print(''.join(starLine))
        print('* %s *' % ''.join(space))
        for n in range(0, max_line):
            print('* %s *' % msg[n])
        print('* %s *' % ''.join(space))
        print(''.join(starLine))

    def infoMsg(self,msg,tag=''):
        self.__tag__(tag).__message__(msg) \
            .__timeMsg__(AppBase.BOLD+AppBase.ITALICS+AppBase.DARK_BLUE) \
            .__header__(AppBase.BOLD+AppBase.DARK_BLUE) \
            .__coloredMsg__(AppBase.ITALICS + AppBase.LIGHT_BLUE) \
            .__tagMsg__(AppBase.LIGHT_AMBER,AppBase.LIGHT_BLUE)
        self.print("%s" % (self.__formattedMsg__()))
        return self

    def install_local(self, verbal = True):
        return self.__install_local__(self.this(), verbal)

    def installedGlobal(self):
        return os.path.exists(self.globalInstallPath()) 

    def installedLocal(self):
        which = self.which()
        if which == '' or which == self.globalInstallPath():    
            return False    
        return os.path.exists(self.which()) 

    def is_bashrc_modified(self):
        # Check if .bashrc file exists and if it contains the modification lines
        if not os.path.isfile(self.bashrc()):
            return False
        
        with open(self.bashrc(), "r") as file:
            contents = file.read()
        
        return "# modified to add ~/.local/bin to PATH" in contents

    def is_zshenv_modified(self):
        # Check if .zshenv file exists and if it contains the modification lines
        if not os.path.isfile(self.zshenv()):
            return False
        
        with open(self.zshenv(), "r") as file:
            contents = file.read()
        
        return "# modified to add ~/.local/bin to PATH" in contents
    def isGlobal(self):
        return self.this() == self.globalInstallPath()

    def isLocal(self):
        which = self.which()
        if which == '' or self.comparePath(which, self.globalInstallPath()):
            return False
        return self.comparePath(self.this(),which)

    def isSudo(self, sudo=None):
        if sudo is not None:
            self.__isSudo__=sudo
            return self
        elif not hasattr(self, '__isSudo__'):
            self.__isSudo__=False
        return self.__isSudo__

    def latest_version(self):
        useRequest = False
        try:
            import requests
            useRequest = True
        except:
            pass
        try:
            if not hasattr(self,'__latest_version__'):
                majorVersion = 0
                minorVersion = 0
                lines = []
                if useRequest:
                    req=requests.get(self.downloadUrl())
                    if str(req.status_code) == '200':
                        lines = req.content.decode('utf8').splitlines()
                else:
                    result, stdout = self.shell("curl -fsSL %s" % ( self.downloadUrl()), True)
                    if result:
                        lines = stdout.splitlines()
                for line in lines:
                    if 'setInstallation' in line and self.appName() in line:
                        for token in line.split(')')[0].split(','):
                            if 'majorVersion' in token:
                                majorVersion = int(token.split('=')[1])
                            if 'minorVersion' in token:
                                minorVersion = int(token.split('=')[1])
                self.__latest_version__="%d.%d" % (majorVersion,minorVersion)
                if majorVersion > self.majorVersion() or (majorVersion == self.majorVersion() and minorVersion> self.minorVersion()):
                    self.__need_update__=True
        except:
            self.criticalMsg("Cannot communicate with server", "CONNECTION FAILED")
        if not hasattr(self,'__latest_version__'):
            self.__latest_version__='0.0'
        return self.__latest_version__

    def lastUpdate(self, lastUpdate=None):
        if lastUpdate is not None:
            self.__lastUpdate__=lastUpdate
            return self
        elif not hasattr(self,'__lastUpdate__'):
            self.__lastUpdate__=None
        return self.__lastUpdate__
    
    def linuxDistro(self):
        if not hasattr(self, '__distro__'):
            self.__distro__=''
            if os.path.isfile("/etc/os-release"):
                fin = open("/etc/os-release", "rt")
                self.__distro__ = ''
                for line in fin:
                    if line.startswith('PRETTY_NAME='):
                        self.__distro__ = line.split('"')[1]
                if 'Alpine' in self.__distro__:
                    self.shellCmd("/bin/ash")
        return self.__distro__

    def local(self):
        return socket.gethostname()

    def localInstallFolder(self):
        return os.path.abspath('%s/.local/bin' % self.home())

    def localInstallPath(self):
        return os.path.abspath('%s/%s' % (self.localInstallFolder(), self.appName()))

    def majorVersion(self, majorVersion=None):
        if majorVersion is not None:
            self.__majorVersion__=majorVersion
            return self
        elif not hasattr(self,'__majorVersion__'):
            self.__majorVersion__=0
        return self.__majorVersion__

    def minorVersion(self, minorVersion=None):
        if minorVersion is not None:
            self.__minorVersion__=minorVersion
            return self
        elif not hasattr(self,'__minorVersion__'):
            self.__minorVersion__=0
        return self.__minorVersion__

    def mkdir_localInstallFolder(self):
        os.mkdir(self.localInstallFolder())

    def need_update(self):
        if not hasattr(self,'__need_update__'):
            self.__need_update__=False
            self.latest_version()
        return self.__need_update__

    def now(self):
        return str(datetime.now())

    def osVersion(self):
        if hasattr(self,'__distro__') and self.__distro__ != "":
            return self.__distro__
        if os.path.exists("/etc/os-release"):
            self.linuxDistro()
        else :
            result, stdout = self.shell("sw_vers -productName")
            if result:
                self.__distro__ = stdout.strip()
            if 'macOS' in self.__distro__:
                self.shellCmd('/bin/zsh')
        return self.__distro__

    def pid(self):
        return os.getpid()

    def print(self, msg):
        print("%s" % msg)
        return self

    def pythonMajor(self, major=None):
        if major is not None:
            self.__python_major__ = major
            return self
        elif not hasattr(self, '__python_major__'):
            self.__python_major__ = 0
        return self.__python_major__

    def pythonMinor(self, minor=None):
        if minor is not None:
            self.__python_minor__ = minor
            return self
        elif not hasattr(self, '__python_minor__'):
            self.__python_minor__ = 0
        return self.__python_minor__

    def pythonName(self, name=None):
        if name is not None:
            self.__python_name__ = name
            return self
        elif not hasattr(self, '__python_name__'):
            self.__python_name__ = 0
        return self.__python_name__

    def pythonVersion(self, version=None):
        if version is not None:
            self.__python_version__ = version
            return self
        elif  hasattr(self, '__python_version__'):
            return self.__python_version__ 
        self.__python_version__ = sys.version
        if len(self.__python_version__.split('\n'))>1:
            self.__python_version__ =  self.__python_version__.split('\n')[0]
        if len( self.__python_version__.split('['))>1:
            self.__python_version__ =  self.__python_version__.split('[')[0]
        if len( self.__python_version__.split('('))>1:
            self.__python_version__ =  self.__python_version__.split('(')[0]
        return self.__python_version__

    def removeFile(self, filePath):
        if os.path.exists(filePath):
            os.remove(filePath)

    def removeFilePattern(self, dirPath, pattern):
        if os.path.exists(dirPath) and os.path.isdir(dirPath):
            for file in os.listdir(dirPath):
                if file.endswith(pattern):
                    os.remove("%s/%s" % (dirPath,file))

    def removeFolder(self, dirPath):
        if os.path.exists(dirPath) and os.path.isdir(dirPath):
            shutil.rmtree(dirPath)

    def safeMsg(self,msg,tag=''):
        self.__tag__(tag).__message__(msg).__timeMsg__(AppBase.BOLD + AppBase.ITALICS + \
            AppBase.DARK_TURQUOISE) \
            .__header__(AppBase.BOLD + AppBase.DARK_TURQUOISE) \
            .__coloredMsg__(AppBase.ITALICS + AppBase.LIGHT_TURQUOISE) \
            .__tagMsg__(AppBase.LIGHT_GREEN,AppBase.LIGHT_TURQUOISE)
        self.print("%s" % (self.__formattedMsg__()))
        return self

    def selfInstall(self, verbal = True):
        if self.isGlobal():
            latest = self.latest_version()
            if self.need_update():
                self.infoMsg("You are using an old (%s.%s) Global Installation's copy already!", "SELF INSTALL" % (self.majorVersion(),self.minorVersion())) 
                if 'yes' == self.__ask_yesno__('Do you want to update from latest (%s) internet? (yes/no) ' % latest):
                    return self.download_and_install(verbal)
            else:
                self.infoMsg("You are using latest (%s) Global Installation's copy already!" % latest, "SELF INSTALL")
                return False
        elif self.isLocal():
            latest = self.latest_version()
            if self.need_update():
                self.infoMsg("You are using an old (%s.%s) Local Installation's copy already!", "SELF INSTALL" % (self.majorVersion(),self.minorVersion())) 
                if 'yes' == self.__ask_yesno__('Do you want to update from latest (%s) internet? (yes/no) ' % latest):  
                    return self.download_and_install(verbal)
            else:
                self.infoMsg("You are using latest (%s) Global Installation's copy already!" % latest, "SELF INSTALL")
                return False
        elif self.installedGlobal():
            self.infoMsg("Global Installation installed already!", "SELF INSTALL")
            if 'yes' == self.__ask_yesno__('Do you want to overwrite the global installation? (yes/no) '):  
                return self.__self_install__(self.this(), verbal)
        elif self.installedLocal():
            self.infoMsg("Local Installation installed already!", "SELF INSTALL")
            if 'yes' == self.__ask_yesno__('Do you want to overwrite the local installation? (yes/no) '):  
                return self.install_local(verbal)
        elif self.username() != 'root':
            if 'yes' == self.__ask_yesno__('Do you want to install locally? (yes/no) '):
                return self.install_local(verbal)
        else:
            return self.__self_install_globally__(verbal)

    def selfLocation(self):
        if self.this() != '':
            return self.this()
        try:
            shell = get_ipython().__class__.__name__
            if shell == 'ZMQInteractiveShell':
                return "Jupyter"
            elif shell == 'TerminalInteractiveShell':
                return "IPython"
            else:
                return "Unknown location"
        except NameError:
            return "Unknown location" 
        
    def selfUninstallGlobal(self, verbal = True):
        if self.installedGlobal():
            result = False
            if self.username() != 'root':
                if self.sudo_test():
                    self.sudoRemoveFile(self.globalInstallPath())
                    result = True
                else:
                    self.criticalMsg("You should be root or sudo to uninstall globally.", "GLOBAL UNINSTALL")
            else:
                self.removeFile(self.globalInstallPath())
                result = True
            if result and verbal:
                self.infoMsg("You have uninstalled successfully. Please run `hash -r` manually!", "LOCAL UNINSTALL")
            return result
        else:
            self.infoMsg("You don't have any global installation.", "GLOBAL UNINSTALL")
        return False

    def selfUninstallLocal(self, verbal = True):
        if self.installedLocal():
            self.removeFile(self.localInstallPath())
            if verbal:
                self.infoMsg("You have uninstalled successfully. Please run `hash -r` manually!", "LOCAL UNINSTALL")
            return True
        else:
            self.infoMsg("You don't have any local installation.", "LOCAL UNINSTALL")
            return False

    def selfUpdate(self,msg="Installation completed!"):
        downloadHost = self.downloadHost()
        if downloadHost=='':
            self.criticalMsg("Cannot Found Host: %s" % downloadHost,"NOT FOUND")
            return ''
        try:
            import requests
        except:
            self.criticalMsg("Please pip3 install requests","PACKAGE NEEDED")
            return ''
        req=requests.get(self.downloadUrl())
        if str(req.status_code) == '200':
            fname="/tmp/%s-%s" % (self.appName(),self.timestamp())
            fp=open(fname,"w")
            fp.write(req.content.decode('utf8'))    
            fp.close()
            self.shell("chmod +x %s" % fname)
            self.safeMsg(msg,"INSTALLATION")
        else:
            self.criticalMsg("Failed to download!","DONWLOAD FAILED")

    def setInstallation(self,appName='',author='',lastUpdate='',homepage='',downloadUrl="",majorVersion=0,minorVersion=0):
        signal.signal(signal.SIGINT, self.signal_handler)
        self.this()
        self.linuxDistro()
        self.osVersion()
        self.arch()
        self.author( author )
        self.appName( appName )
        self.downloadUrl( downloadUrl )
        self.homepage( homepage )
        self.lastUpdate( lastUpdate )
        self.majorVersion( majorVersion )
        self.minorVersion( minorVersion )

    def shell(self, command, ignoreErr=False):
        stdout,stderr = Popen([self.shellCmd(),'-c',command],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        if stderr != "" and not ignoreErr:
            self.criticalMsg("Error in %s: %s" % (command, stderr), "ERROR")
            return False, stderr
        else:
            return True, stdout

    def shellCmd(self, cmd=None):
        if cmd is not None:
            self.__shellCmd__=cmd
            return self
        elif not hasattr(self,'__shellCmd__'):
            self.__shellCmd__='/bin/bash'
        return self.__shellCmd__

    def signal_handler(self, sig, frame):
        print('\nYou pressed Ctrl+C!')
        sys.exit(0)

    def sudo_test(self,msg='.'):
        distro = self.osVersion()
        if self.isSudo():
            return True
        if distro.startswith('Alpine'):
            stdout,stderr = Popen([ self.shellCmd(), '-c' , "which sudo" ],\
                stdin=PIPE,stdout=PIPE,stderr=PIPE,universal_newlines=True)\
                .communicate( '\n' )
            if stdout=='':
                return False
        stdout,stderr = Popen([ self.shellCmd(), '-c' , "sudo echo %s" % msg ],\
            stdin=PIPE,stdout=PIPE,stderr=PIPE,universal_newlines=True)\
            .communicate( '\n' )
        trial=0
        while stdout.strip() != msg.strip() and trial < 3:
            sudoPassword=getpass.getpass( 'Please input "sudo" password for %s: ' % self.username() )
            stdout, stderr = Popen([ self.shellCmd() , '-c',"sudo echo %s" % msg ] \
                ,stdin=PIPE,stdout=PIPE,stderr=PIPE,\
                universal_newlines=True ).communicate( "%s\n" % sudoPassword )
            trial=trial + 1
        if trial < 3:
            self.isSudo( True )
        return self.isSudo()

    def sudoRemoveFile(self, filePath):
        self.shell( 'sudo rm -rf %s' % filePath )

    def tag(self, tag=None):
        if tag is not None:
            self.__TAG__=tag
            return self
        elif not hasattr( self, '__TAG__' ):
            self.__TAG__=''
        return self.__TAG__

    def this(self, this = None):
        if this is None :
            if hasattr(self, '__this__'):
                return self.__this__
            if __file__ is None or __file__ == '<stdin>':
                self.appPath('')
                return ''
            else:
                appPath = os.path.abspath(__file__)
                if not appPath.startswith(self.globalInstallRoot()):
                    if self.comparePath(appPath, '%s/%s' % (os.getcwd(),appPath.split("/")[-1])):
                        self.appPath("./%s" % appPath.split("/")[-1])
                    elif self.comparePath(appPath, self.which()):
                        self.appPath(appPath.split("/")[-1])
                    else:
                        self.appPath(appPath)
                else:
                    self.appPath(appPath.split("/")[-1])  
                return appPath
        else:
            self.__this__ = this
            return self

    @staticmethod
    def thisFile():
        return AppBase.__here__

    def timestamp(self):
        return "%s" % (int(time.time()))

    def which(self):
        return self.which_cmd( self.appName())

    def which_cmd(self, cmd):
        result, stdout = self.shell("which %s" % cmd, ignoreErr=True)
        return stdout.strip()

    def useColor(self, color=None):
        if color is not None:
            self.__useColor__=color
            return self
        elif not hasattr(self, '__useColor__'):
            self.__useColor__=True
        return self.__useColor__

    def userID(self):
        return os.getuid()

    def username(self):
        return pwd.getpwuid(self.userID())[0]

    def version(self):
        return "%s.%s" % (self.majorVersion(),self.minorVersion())

    def zshenv(self):
        return os.path.join(self.home(), ".zshenv")

class OnlineInstaller(AppBase):

    def install_target_global(self, this):
        if self.targetApp() != '':
            result, stdout = self.shell("rm -rf %s/%s" % (self.globalInstallRoot(), self.targetApp()))
        result, stdout = self.shell("cp %s %s" % ( this, self.globalInstallRoot()))
        result, stdout = self.shell("chmod +x %s/%s" % (self.globalInstallRoot(), self.targetApp()))
        if result:
            self.safeMsg("Installed Globally! \n  Your OS is: %s\n  Please type 'hash -r'%s to refresh bash shell hash!\n  Then, you can type '%s' to run!" 
                % (self.osVersion(), startSh, self.targetApp()), "SELF INSTALL")

    def install_target_local(self, this):
        result, stdout = self.shell("mkdir -p %s" % self.localInstallFolder())
        if self.targetApp() != '':
            result, stdout = self.shell("rm -rf %s/%s" % (self.localInstallFolder(), self.targetApp()))
        result, stdout = self.shell("cp %s %s" % ( this, self.localInstallFolder()))
        result, stdout = self.shell("chmod +x %s/%s" % (self.localInstallFolder(), self.targetApp()))
        startSh =  ""
        if self.osVersion() == 'macOS':
            self.check_and_modify_zshenv()
            startSh = " and 'source ~/.zshenv'"
        elif self.osVersion() != 'Alpine' :
            self.check_and_modify_bashrc()
            startSh =  " and 'source ~/.bashrc'"
        if result:
            self.safeMsg("Installed Locally! \n  Your OS is: %s\n  Please type 'hash -r'%s to refresh bash shell hash!\n  Then, you can type '%s' to run!" 
                % (self.osVersion(), startSh, self.targetApp()), "SELF INSTALL")

    def downloadTarget(self):
        if self.targetApp() == '':
            return
        fname = '/tmp/%s.tar.gz' % self.targetApp()
        self.print("  ... downloading %s ..." % self.targetDownloadUrl())
        result, stdout = self.shell("curl -fsSL -o %s %s" % (fname, self.targetDownloadUrl()), True)
        if result:
            os.chdir('/tmp')
            result, stdout = self.shell("tar -xvf %s.tar.gz" % ( self.targetApp()), True)
            this = "/tmp/%s" % self.targetApp()
            self.this(this)
            if self.username() == 'root':
                self.install_target_local(this)
            else:
                self.install_target_local(this)

    def start(self):
        self.allowInstallLocal(True)
        self.__parseArgs__()

    def targetApp(self, app=None):
        if app is not None:
            self.__target_app__=app
            return self
        elif not hasattr( self, '__target_app__' ):
            self.__target_app__=''
        return self.__target_app__

    def targetDownloadUrl(self):
        libc = 'glibc'
        if 'Clang' in self.gccVersion():
            libc = 'clang'
        return "%s%s-%s/%d.%d/%s.tar.gz" % (self.downloadUrl(), self.arch().split(' ')[0].lower(), libc, self.majorVersion(),self.minorVersion(), self.targetApp())

    def __parseArgs__(self, allowSelfInstall = True, allowDisplayInfo = True):
        if self.isLocal() or self.isGlobal():
            appPath = self.appName()
        elif self.appPath() != '' :
            appPath = './' + self.appName()
        else:
            appPath = ''
        usage = "%s [check-update|install|uninstall]" % appPath
        if self.appPath() != '' :
            if len(sys.argv) > 1:
                self.cmd(sys.argv[1])
                if self.cmd() == "install":
                    if self.selfInstall(False):
                        self.downloadTarget()
                elif self.cmd() == "uninstall":
                    if self.installedGlobal():
                        if self.selfUninstallGlobal(False):
                            self.removeFile("%s/%s" % (self.globalInstallRoot(), self.targetApp()))
                            self.infoMsg("You have uninstalled globally successfully. Please run `hash -r` manually!", "GLOBAL UNINSTALL")
                        else:
                            self.criticalMsg("Failed to uninstall globally", "UNINSTALL FAILED")
                    elif self.installedLocal():
                        if self.selfUninstallLocal(False):
                            self.removeFile("%s/%s" % (self.localInstallFolder(), self.targetApp()))
                            self.infoMsg("You have uninstalled locally successfully. Please run `hash -r` manually!", "LOCAL UNINSTALL")
                        else:
                            self.criticalMsg("Failed to uninstall locally", "UNINSTALL FAILED")
                    else:
                        self.infoMsg("You don't have any global or local installation.", "UNINSTALL")
                elif self.cmd() == "check-update":
                    latest = self.latest_version()
                    if self.need_update():
                        self.infoMsg("Latest Version = %s\n  Update is available" % latest, "CHECK UPDATE")
                    elif latest != '0.0':
                        self.infoMsg("You are using most updated version: %s" % latest, "CHECK UPDATE")
                elif allowDisplayInfo:
                    self.info(usage)
            elif allowDisplayInfo:
                self.info(usage)
        elif allowSelfInstall:
            if '<stdin>' == self.thisFile():
                if self.download_and_install(False):
                    self.downloadTarget()
            else:
                if self.selfInstall(False):
                    self.downloadTarget()

if __name__ == "__main__":
    app = OnlineInstaller()
    app.targetApp('german-num')
    app.setInstallation(appName='spanish-num-installer',author='Cloudgen Wong',homepage="https://github.com/cloudgen2/spanish-num",downloadUrl="https://dl.leolio.page/spanish-num/",lastUpdate='2023-10-08',majorVersion=0,minorVersion=3)
    app.start() 

