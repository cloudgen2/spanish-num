#!/bin/sh
# -*- coding: utf-8 -*-
##! 0<0# : ^
##! """
##! @echo off
##! SET F="C:\\Users\\%USERNAME%\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe"
##! if exist %F% ( del /s %F% >nul 2>&1 )
##! SET G="C:\\Users\\%USERNAME%\\AppData\\Local\\Microsoft\\WindowsApps\\python3.exe"
##! if exist %G% ( del /s %G% >nul 2>&1 )
##! FOR /F "tokens=*" %%g IN ('where python.exe') do (SET VAR=%%g)
##! if exist %VAR% (
##!     python "%~f0" %*
##!     exit /b 0
##! )
##! FOR /F "tokens=*" %%g IN ('where python3.exe') do (SET VAR=%%g)
##! if exist %VAR% ( python3 "%~f0" %* )
##! exit /b 0
##! """
""":"
if [ -f /usr/bin/sw_vers ]; then
  WHICH='which'
elif [ -f /usr/bin/which ]; then
  WHICH='/usr/bin/which'
elif [ -f /bin/which ]; then
  WHICH='/bin/which'
elif [ -f "C:\\Windows\\System32\\where.exe" ]; then
  WHICH="C:\\Windows\\System32\\where.exe"
fi
if [ ! -z $WHICH ]; then
    _PY_=$($WHICH python3)
    if [ -z $_PY_ ]; then _PY_=$($WHICH python2); if [ -z $_PY_ ]; then _PY_=$($WHICH pypy3); if [ -z $_PY_ ]; then _PY_=$($WHICH pypy); if [ -z $_PY_ ]; then _PY_=$($WHICH python); if [ -z $_PY_ ]; then echo 'No Python Found'; fi; fi; fi; fi; fi; 
    if [ ! -z "$_PY_" ]; then
        WINPTY=$($WHICH winpty.exe)
        if [ ! -z "$WINPTY" ]; then
            PY_EXE=$($WHICH python.exe)
            if [ ! -z "$PY_EXE" ]; then
                exec "$WINPTY" "$PY_EXE" "$0" "$@"
                exit 0
            fi
        else
            exec $_PY_ "$0" "$@"
            exit 0
        fi
    fi
fi
if [  -f /usr/bin/python3 ]; then
    exec /usr/bin/python3 "$0" "$@"
    exit 0
fi
if [  -f /usr/bin/python2 ]; then
    exec /usr/bin/python2 "$0" "$@"
    exit 0
if [  -f /usr/bin/python ]; then
    exec /usr/bin/python "$0" "$@"
    exit 0
fi
if [  -f /usr/bin/pypy3 ]; then
    exec /usr/bin/pypy3 "$0" "$@"
    exit 0
fi 
if [  -f /usr/bin/pypy ]; then
    exec /usr/bin/pypy "$0" "$@"
    exit 0
fi
# This is code from online-installer, homepage: https://github.com/cloudgen2/online-installer
exit 0
":"""
from __future__ import print_function
try:
    raw_input
except NameError:
    raw_input = input
try:
    basestring
except NameError:
    basestring = str
try: 
    __file__
except NameError: 
    __file__ = ''

try:
    import pwd
except:
    pwd = None

from datetime import datetime
import getpass
import os
import platform
import re
import signal
from subprocess import Popen, PIPE
import subprocess
import shutil
import socket
import time
import sys

class AppBase(object):

    BOLD='\033[1m'
    DARK_AMBER='\033[33m'
    DARK_BLUE='\033[34m'
    DARK_TURQUOISE='\033[36m'
    END='\033[0m'
    FLASHING='\033[5m'
    ITALICS='\033[3m'
    LIGHT_RED='\033[91m'
    LIGHT_AMBER='\033[93m'
    LIGHT_BLUE='\033[94m'
    LIGHT_GREEN='\033[92m'
    LIGHT_TURQUOISE='\033[96m'

    __here__ = __file__

    def __alpine_ask_install_sudo__(self):
        if 'yes' == self.__ask_yesno__('Do you want to install sudo? (yes/no) '):
            r
            esult, stdout = self.shell("apk add sudo", True)
            result, stdout = self.shell("echo '%wheel ALL=(ALL) ALL' > /etc/sudoers.d/wheel")

    def __ask_yesno__(self, ask):
        if not hasattr(self, '__regex_yesno__'):
            self.__regex_yesno__ = re.compile(r"yes|no")
        ask_yesno = raw_input(ask).strip().lower()
        while ask_yesno == '' or self.__regex_yesno__.sub("",ask_yesno) != '':
            ask_yesno = raw_input(ask).strip().lower()
        return ask_yesno

    def __coloredMsg__(self,color=None):
        if color is None :
            if self.__message__() == '':
                return ''
            else:
                return "%s%s%s" % (self.__colorMsgColor__(),\
                    self.__message__(),self.__colorMsgTerm__())
        else:
            if color == '' or not self.useColor():
                self.__colorMsgColor__('')
                self.__colorMsgTerm__('')
            else:
                self.__colorMsgColor__(color)
                self.__colorMsgTerm__(AppBase.END)
            return self

    def __colorMsgColor__(self, color=None):
        if color is not None:
            self.__cmc__=color
            return self
        elif not hasattr(self,'__cmc__'):
            self.__cmc__=""
        return self.__cmc__

    def __colorMsgTerm__(self,term=None):
        if term is not None:
            self.__cmt__=term
            return self
        elif not hasattr(self,'__cmt__'):
            self.__cmt__=""
        return self.__cmt__

    def __formattedMsg__(self):
        return "%s %s %s\n  %s" % (self.__timeMsg__(),self.__header__(),\
            self.__tagMsg__(),self.__coloredMsg__())

    def __header__(self,color=None):
        if color is None:
            return "%s%s(v%s) %s" % (self.__headerColor__(),\
                self.appName(),self.version(),\
                self.__headerTerm__())
        else:
            if color == '' or not self.useColor():
                self.__headerColor__('')\
                    .__headerTerm__('')
            else:
                self.__headerColor__(color)\
                    .__headerTerm__(AppBase.END)
        return self

    def __headerColor__(self,color=None):
        if color is not None:
            self.__hc__=color
            return self
        elif not hasattr(self,'__hc__'):
            self.__hc__=""
        return self.__hc__

    def __headerTerm__(self,term=None):
        if term is not None:
            self.__ht__=term
            return self
        elif not hasattr(self,'__ht__'):
            self.__ht__=""
        return self.__ht__

    def __install_local__(self, this = None, verbal = True ):
        result = False
        if this is None:
            this = self.thisFile()
        if self.isCmd() or self.isGitBash():
            file = 'C:\\Users\\%s\\AppData\\Local\\Microsoft\\WindowsApps\\%s.bat' % (self.username(),self.appName())
            file2 = self.open(file,'w')
            if self.pathexists(this):
                file1 = self.open(this, 'r')
                for line in file1:
                    if line.startswith('##! '):
                        file2.write(line[4:])
                    elif not (line.startswith('from __future__') or line.startswith('#!') or line.startswith('# -*-')):
                        file2.write(line)
                file1.close()
                file2.close()
                self.removeFile(this)
                result = True
            else:
                result = False
        else:
            folder=self.localInstallFolder()
            self.mkdir(folder)
            file=self.localInstallPath()
            self.removeFile(file)
            if self.pathexists(this):
                file1 = self.open(this, 'r')
                file2 = self.open(os.path.realpath(file),'w')
                for line in file1:
                    if line.startswith('#!/bin/sh'):
                        file2.write('#!%s\n' % sys.executable)
                    else:
                        file2.write(line)
                file1.close()
                file2.close()
                self.removeFile(this)
                result, stdout = self.shell("chmod +x %s" % file)
                result = True
            else:
                self.msg_download_not_found(this)
                result = False
            if this.startswith('/tmp'):
                self.removeFile(this)
        if self.osVersion() == 'macOS':
            self.check_and_modify_zshenv()
        elif self.osVersion() != 'Alpine' :
            if self.shellCmd() == '/bin/bash':
                self.check_and_modify_bashrc()
            elif self.shellCmd() == '/bin/ash':
                self.check_and_modify_bashrc()
        if result:
            if verbal:
                if self.targetApp() == '':
                    self.msg_install_app_local()
                else:
                    self.msg_install_target_local()
        return result

    def __message__(self,message=None):
        if message is not None:
            self.__m__=message
            return self
        elif not hasattr(self,'__m__'):
            self.__m__=""
        return self.__m__

    def __self_install__(self, this=None, verbal = True):
        if this is None:
            this = self.thisFile()
        result = False
        try_global = True
        if self.username() != 'root':
            if self.allowInstallLocal():
                if self.__ask_yesno__('You are not using root account. Do you want to continue? (yes/no) ') == 'yes':
                    if self.__ask_yesno__('Install globally (yes) or locally(no)? (yes/no) ') == 'no':
                        try_global = False
                        result = self.__install_local__()
            elif self.__ask_yesno__('You are not using root account. Do you want to continue? (yes/no) ') == 'no':
                try_global = False
                result = False
                if try_global:
                    if self.osVersion() == 'Alpine':
                        self.msg_alpine_detected()
                        self.msg_sudo_failed()
                        result = False
                    elif self.sudo_test():
                        result, stdout = self.shell("sudo cp %s %s" % (this, self.globalInstallPath()))
                        result, stdout = self.shell("sudo chmod +x %s" % self.globalInstallPath())
                    else:
                        self.msg_sudo_failed()
                        result = False
        else:
            file = self.globalInstallPath()
            if self.pathexists(this):
                file1 = self.open(this, 'r')
                file2 = self.open(os.path.realpath(file),'w')
                for line in file1:
                    if line.startswith('#!/bin/sh'):
                        file2.write('#!%s\n' % sys.executable)
                    else:
                        file2.write(line)
                file1.close()
                file2.close()
                self.removeFile(this)
                result, stdout = self.shell("chmod +x %s" % file)
            else:
                self.msg_download_not_found(file)
                result = False
        if result:
            if try_global and verbal:
                self.msg_install_app_global()
        return result

    def __self_install_globally__(self, verbal = True):
        if self.sudo_test():
            return self.__self_install__(self.thisFile(), verbal)
        elif self.username() != 'root':
            self.msg_root_continue()
            return False
        else:
            return self.__self_install__(self.thisFile(), verbal)

    def __tag__(self, tag=None):
        if tag is not None:
            self.__t__=tag
            return self
        elif not hasattr(self,'__t__'):
            self.__t__=''
        return self.__t__

    def __tagColor__(self, color=None):
        if color is not None:
            self.__tc__=color
            return self
        elif not hasattr(self,'__tc__'):
            self.__tc__=''
        return self.__tc__

    def __tagMsg__(self,color=None,outterColor=None):
        if color is None:
            if self.__tag__() == '' or not self.useColor():
                return '[%s]: ' % self.__tag__()
            else:
                return "%s[%s%s%s%s%s]:%s " % (self.__tagOutterColor__(),\
                    self.__tagTerm__(),self.__tagColor__(),\
                    self.__tag__(),self.__tagTerm__(),\
                    self.__tagOutterColor__(),self.__tagTerm__())
        else:
            if color == '':
                self.__tagColor__('')\
                    .__tagOutterColor__('')\
                    .__tagTerm__('')
            else:
                self.__tagColor__(color)\
                    .__tagOutterColor__(outterColor)\
                    .__tagTerm__(AppBase.END)
            return self

    def __tagOutterColor__(self, color=None):
        if color is not None:
            self.__toc__=color
            return self
        elif not hasattr(self,'__toc__'):
            self.__toc__=''
        return self.__toc__
    
    def __tagTerm__(self, term=None):
        if term is not None:
            self.__tt__=term
            return self
        elif not hasattr(self,'__tt__'):
            self.__tt__=''
        return self.__tt__

    def __timeColor__(self, color=None):
        if color is not None:
            self.__tcolor__=color
            return self
        elif not hasattr(self,'__tcolor__'):
            self.__tcolor__=''
        return self.__tcolor__

    def __timeMsg__(self, color=None):
        if color is None:
            return "%s%s%s" % (self.__timeColor__(),self.now(),\
                self.__timeTerm__())
        else:
            if color == '' or not self.useColor():
                self.__timeColor__('')\
                    .__timeTerm__('')
            else:
                self.__timeColor__(color)\
                    .__timeTerm__(AppBase.END)
            return self

    def __timeTerm__(self, term=None):
        if term is not None:
            self.__tterm__=term
            return self
        elif not hasattr(self,'__tterm__'):
            self.__tterm__=''
        return self.__tterm__

    def add_bashrc_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "# modified to add ~/.local/bin to PATH",
            "PATH=$PATH:~/.local/bin\n"
        ]
        
        with self.open(self.bashrc(), "a") as file:
            file.write("\n".join(modification_lines))
        self.shell('chmod +x %s' % self.bashrc())

    def add_zshenv_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "\n# modified to add ~/.local/bin to PATH",
            "path+=('%s')" %  os.path.join(self.home(), ".local/bin"),
            "export PATH\n"
        ]
        with self.open(self.zshenv(), "a") as file:
            file.write("\n".join(modification_lines))

    def allowInstallLocal(self, installLocal=None):
        if installLocal is not None:
            self.__allowInstallLocal__=installLocal
            return self
        elif not hasattr(self,'__allowInstallLocal__'):
            self.__allowInstallLocal__=False
        return self.__allowInstallLocal__

    def appExec(self):
        if not hasattr(self, '__app_path__'):
            self.appPath()
        if not hasattr(self, '__app_exec__'):
            self.__app_exec__ = ''
            if self.isLocal() or self.isGlobal():
                if self.isCmd() or self.isGitBash():
                    self.__app_exec__ = self.appName() + '.bat'
                else:
                    self.__app_exec__ = self.appName()
            elif self.appPath() != '' :
                if self.isCmd() or self.isGitBash():
                    self.__app_exec__ = self.appName() + '.bat'
                elif self.isLinuxShell():
                    self.__app_exec__='./' + self.appName()
                else:
                    self.__app_exec__='./' + self.appName()
        return self.__app_exec__

    def fromPipe(self):
        return self.thisFile() == '<stdin>'

    def appPath(self, path=None):
        if path is not None:
            self.__app_path__=path
            return self
        elif not hasattr(self,'__app_path__'):
            self.__app_path__=''
            if not self.fromPipe() and self.thisFile() != '':
                appPath = os.path.abspath(self.thisFile())
                if not appPath.startswith(self.globalInstallRoot()):
                    if self.comparePath(appPath, '%s/%s' % (os.getcwd(),appPath.split("/")[-1])):
                        self.__app_path__="./%s" % appPath.split("/")[-1]
                    elif self.comparePath(appPath, self.which()):
                        self.__app_path__=appPath.split("/")[-1]
                    else:
                        self.__app_path__=appPath
                else:
                    self.__app_path__=appPath.split("/")[-1]
        return self.__app_path__

    def arch(self):
        if not hasattr(self, '__arch__'):
            if self.isCmd():
                self.__arch__ = 'amd64'
            else:
                result2, stdout2 = self.uname_a()
                result, stdout = self.uname_m()
                if result:
                    self.__arch__ = stdout.strip()
                    # "aarch64" and "arm64" are the same thing. AArch64 is the official name for the 64-bit ARM architecture, 
                    # but some people prefer to call it "ARM64" as a continuation of 32-bit ARM.
                    if self.__arch__ == 'arm64':
                        self.__arch__ = 'aarch64'
                    elif 'ARM64' in stdout2:
                        self.__arch__ = 'aarch64'
                    # X86_64 and AMD64 are different names for the same thing
                    elif self.__arch__ == 'x86_64':
                        self.__arch__ = 'amd64'
                else:
                    self.__arch__=''
        return self.__arch__

    def author(self, author=None):
        if author is not None:
            self.__author__=author
            return self
        elif not hasattr(self,'__author__'):
            self.__author__=None
        return self.__author__

    def appName(self, appName=None):
        if appName is not None:
            self.__appName__=appName
            return self
        elif not hasattr(self,'__appName__'):
            self.__appName__=''
        return self.__appName__

    def bashrc(self):
        if self.shellCmd() == '/bin/ash':
            return os.path.join(self.home(), ".profile")
        return os.path.join(self.home(), ".bashrc")

    def binaryVersion(self, version=None):
        if version is not None:
            self.__binary_version__ = version
            return self 
        elif not hasattr(self,'__binary_version__'):
            self.__binary_version__ = ''
        return self.__binary_version__

    def check_and_modify_bashrc(self):
        if not self.is_bashrc_modified():
            self.add_bashrc_modification()

    def check_and_modify_zshenv(self):
        if not self.is_zshenv_modified():
            self.add_zshenv_modification()

    def checkSystem(self):
        if self.pythonVersion().split(".")[0] =="3":
            self.pythonName( "python3" )
            major = 3
        else:
            self.pythonName( "python2" )
            major = 2
        minor = int(self.pythonVersion().split(".")[0])
        gcc = sys.version
        self.arch()
        if '\n' in gcc:
            gcc = gcc.split('\n')[1]
        elif '[' in gcc and ']' in gcc:
            gcc = gcc.split('[')[1].split(']')[0]
        if gcc=='GCC':
            gcc= '[GCC]'
        if ' (Red Hat' in gcc:
            gcc = gcc.split(' (Red Hat')[0] + ']'
        if '[PyPy ' in gcc and 'with' in gcc:
            pythonVersion = gcc.split('with')[0].split('[')[1].strip()
            self.pythonVersion("%s (%s)" % (self.pythonVersion(), pythonVersion))
            gcc = '[' + gcc.split('with ')[1]
            if self.pythonName() == "python3":
                self.pythonName( "pypy3")
            else:
                self.pythonName( "pypy" )
        if platform.libc_ver()[0]!='':
                self.libcName( platform.libc_ver()[0] )
        if 'AMD64' in gcc:
            self.__arch__ = 'amd64'
            if 'MSC' in gcc:
                self.libcName('msc')
        elif 'AMD32' in gcc:
            self.libcName('msc')
            self.__arch__ = 'x86'
        if 'clang' in gcc:
            self.libcName('clang')
        self.libcVersion(gcc)
        self.osVersion()
        self.shellCmd()
        self.this()
        self.linuxDistro()
        if self.libcName()  == '' and self.shellCmd() == '/bin/ash':
            self.libcName('muslc')
        if self.arch() != '':
            if self.libcName() == '':
                self.binaryVersion('%s-' % (self.arch()))
            else:
                self.binaryVersion('%s-%s' % (self.arch(), self.libcName()))

    def checkUpdate(self):
        if self.need_update():
            self.msg_latest_available()
        elif self.latest_version() != '0.0':
            self.msg_latest()

    def cmd(self, cmd=None):
        if cmd is not None:
            self.__cmd__=cmd
            return self
        elif not hasattr(self, '__cmd__'):
            self.__cmd__=False
        return self.__cmd__

    def cmdList(self, x=None, rstrip=False):
        if not hasattr(self,'__cmdList__'):
            self.__cmdList__=[]
        if x is not None:
            if isinstance(x,list):
                for l in x:
                    if isinstance(l,basestring) and rstrip:
                        self.__cmdList__.append(l.rstrip())
                    else:
                        self.__cmdList__.append(l)
            else:
                self.__cmdList__.append(x)
            return self
        return self.__cmdList__

    def comparePath(self, p1, p2):
        return os.path.abspath(p1)==os.path.abspath(p2)

    def criticalMsg(self,msg,tag=''):
        self.__tag__(tag).__message__(msg) \
            .__timeMsg__(AppBase.BOLD + AppBase.ITALICS + \
            AppBase.DARK_AMBER) \
            .__header__(AppBase.BOLD + AppBase.DARK_AMBER) \
            .__coloredMsg__(AppBase.ITALICS + AppBase.LIGHT_AMBER) \
            .__tagMsg__(AppBase.FLASHING + AppBase.LIGHT_RED,\
            AppBase.LIGHT_AMBER)
        self.prn("%s" % (self.__formattedMsg__()))
        return self

    def curl_cmd(self, url='', file='', switches='-fsSL',  ignoreErr=True):
        stderr = 'Unknown Error'
        stdout = ''
        if self.isLinuxShell():
            curl = self.which_cmd('curl')
            if url!='' and file!='':
                stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        elif self.isGitBash():
            winpty = self.where_cmd('winpty.exe')
            curl = self.where_cmd('curl.exe')
            if url!='' and file!='':
                file=self.path_to_dos(file)
                stdout,stderr = Popen([winpty,curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
                if stderr.strip().lower() == 'stdin is not a tty':
                    stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                        stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                stdout,stderr = Popen([winpty,curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
                if stderr.strip().lower() == 'stdin is not a tty':
                    stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                        stderr=PIPE,universal_newlines=True).communicate('\n')
        elif self.isCmd():
            curl = self.where_cmd('curl.exe')
            if url!='' and file!='':
                stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        elif url!='':
            # Assume /bin/sh as default shell
            curl = self.which_cmd('curl')
            if url!='' and file!='':
                stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        if stderr != "" and not ignoreErr:
            self.msg_error(command, stderr)
            return False, stderr
        return True, stdout

    def curl_download(self, url='', file='', ignoreErr=True):
        if self.curl_is_200(url):
            self.curl_cmd(url=url, file=file, ignoreErr=ignoreErr)
            if file == '':
                return True
            if file !='' and not self.pathexists(file):
                count=20
                # In gitbash, downloading time may be longer
                self.msg_downloading(file)
                while count>0 and  not self.pathexists(file):
                    count = count - 1
                    time.sleep(1) # wait for curl download the file
            if file !='' and self.pathexists(file):
                return True
            elif ignoreErr:
                return True
            else:
                self.msg_timeout(file)
                return False
        return False

    def curl_is_200(self, url):
        result, stdout = self.curl_cmd(url=url, switches='-fsSLI', ignoreErr=True)
        if result:
            result = False
            for rawline in stdout.splitlines():
                line = rawline.strip()
                if 'HTTP' in line.strip():
                    line_split=line.split(' ')
                    if len(line_split) > 1:
                        if  '200' == line_split[1] or '301' == line_split[1] or '302' == line_split[1]:
                            return True
                        else:
                            self.msg_download_url_error(url, line_split[1])
                            return False
        return result


    def curPath(self, curPath=None):
        if curPath is not None:
            self.__curPath__=curPath
            return self
        elif not hasattr(self, '__curPath__'):
            pw='%s' % os.getcwd()
            if self.isGitBash() and ':' in pw:
                pw=pw.split(':')
                self.__curPath__='/'+pw[0]+'/'.join(pw[1].split('\\'))
            else:
                self.__curPath__=pw
        return self.__curPath__

    def download_to_temp(self, url=None, file=None,verbal = False):
        self.msg_system_check()
        if url is None:
            url=self.downloadUrl()
        if file is None:
            file=self.tempFile()
        result = self.curl_download(url=url, file=file)
        if not self.pathexists(file):
            result = False
            self.msg_download_error(file)
        elif verbal:
            self.msg_downloaded(file)
        return result

    def download_and_install(self, verbal = True):
        if self.targetApp() != '':
            result = self.download_and_install_target()
        else:
            result=True
        if result:
            fname = self.tempFile()
            self.download_to_temp(verbal=False)
            if self.pathexists(fname):
                if self.username() == 'root':
                    return self.__self_install__(fname, verbal)
                else:
                    return self.__install_local__(fname, verbal)
        return False

    def downloadHost(self):
        if self.downloadUrl() == '':
            return ''
        x = re.search("https:..([^/]+)", self.downloadUrl())
        if x:
            return x.group(1)
        else:
            ''

    def download_and_install_target(self):
        if self.targetApp() == '':
            return
        fname = self.tempTargetGzip()
        self.download_to_temp(url=self.tempAppUrl(), file=fname, verbal=False)
        if self.pathexists(fname):
            os.chdir(self.tempFolder())
            result, stdout = self.shell("tar -xvf %s" % fname.split('/')[-1], True)
            this = self.tempAttachDecomp()
            if self.pathexists(this):
                self.this(this)
                if self.username() == 'root':
                    self.install_target_global(this)
                else:
                    self.install_target_local(this)
                return True
            else:
                self.msg_extraction_error(this)
                return False
        else:
            self.msg_download_error(self.tempTargetGzip())
            return False

    def downloadUrl(self, downloadUrl=None):
        if downloadUrl is not None:
            self.__downloadUrl__=downloadUrl
            return self
        elif not hasattr(self,'__downloadUrl__'):
            self.__downloadUrl__=None
        return self.__downloadUrl__

    def duplication_warning(self):
        if self.installedLocal() and self.installedGlobal():
            self.msg_both_local_global()

    def executable(self):
        if hasattr(self, '__executable__'): 
            return self.__executable__
        if '/' in sys.executable:
            self.__executable__  = sys.executable.split('/')[-1]
        elif '\\'  in sys.executable:
            self.__executable__  = sys.executable.split('\\')[-1]
        else:
            self.__executable__ = ''
        return self.__executable__ 

    def globalInstallPath(self):
        return '%s%s' % (self.globalInstallRoot(), self.appName())

    def globalInstallRoot(self, path=None):
        if path is not None:
            self.__globalInstallRoot__=path
            return self
        elif not hasattr(self,'__globalInstallRoot__'):
            self.__globalInstallRoot__='/usr/local/bin/'
        return self.__globalInstallRoot__

    def hasGlobalInstallation(self):
        return  self.pathexists(self.globalInstallPath())

    def home(self):
        return os.path.expanduser("~")

    def homepage(self, homepage=None):
        if homepage is not None:
            self.__homepage__=homepage
            return self
        elif not hasattr(self,'__homepage__'):
            self.__homepage__=None
        return self.__homepage__

    def infoMsg(self,msg,tag=''):
        self.__tag__(tag).__message__(msg) \
            .__timeMsg__(AppBase.BOLD+AppBase.ITALICS+AppBase.DARK_BLUE) \
            .__header__(AppBase.BOLD+AppBase.DARK_BLUE) \
            .__coloredMsg__(AppBase.ITALICS + AppBase.LIGHT_BLUE) \
            .__tagMsg__(AppBase.LIGHT_AMBER,AppBase.LIGHT_BLUE)
        self.prn("%s" % (self.__formattedMsg__()))
        return self

    def install_local(self, verbal = True):
        return self.__install_local__(self.thisFile(), verbal)

    def installedGlobal(self):
        return self.pathexists(self.globalInstallPath()) 

    def installedLocal(self):
        which = self.which()
        if which == '' or which == self.globalInstallPath():    
            return False    
        return self.pathexists(self.which()) 

    def install_target_global(self, this):
        if self.targetApp() != '':
            self.sudoRemoveFile("%s/%s" % (self.globalInstallRoot(), self.targetApp()))
        result, stdout = self.shell("cp %s %s" % ( this, self.globalInstallRoot()))
        result, stdout = self.shell("chmod +x %s/%s" % (self.globalInstallRoot(), self.targetApp()))
        if result:
            self.msg_install_target_global()

    def install_target_local(self, this):
        self.mkdir( self.localInstallFolder() )
        if self.targetApp() != '':
            self.removeFile("%s/%s" % (self.localInstallFolder(), self.targetApp()))
        result, stdout = self.shell("cp %s %s" % ( this, self.localInstallFolder()))
        result, stdout = self.shell("chmod +x %s/%s" % (self.localInstallFolder(), self.targetApp()))
        if self.osVersion() == 'macOS':
            self.check_and_modify_zshenv()
        elif self.osVersion() != 'Alpine' :
            self.check_and_modify_bashrc()

    def is_bashrc_modified(self):
        # Check if .bashrc file exists and if it contains the modification lines
        if not os.path.isfile(self.bashrc()):
            return False
        
        with self.open(self.bashrc(), "r") as file:
            contents = file.read()
        
        return "# modified to add ~/.local/bin to PATH" in contents

    def is_zshenv_modified(self):
        # Check if .zshenv file exists and if it contains the modification lines
        if not os.path.isfile(self.zshenv()):
            return False
        
        with self.open(self.zshenv(), "r") as file:
            contents = file.read()
        
        return "# modified to add ~/.local/bin to PATH" in contents

    def isCmd(self):
        if not hasattr(self, '__is_cmd__'):
            if not hasattr(self, '__shell_cmd__'):
                self.shellCmd()
            self.__is_cmd__ = self.__shell_cmd__.split('\\')[-1] == 'cmd.exe' 
        return self.__is_cmd__

    def isGitBash(self):
        if not hasattr(self, '__is_gitbash__'):
            if not hasattr(self, '__shell_cmd__'):
                self.shellCmd()
            self.__is_gitbash__ = self.__shell_cmd__.split('\\')[-1] == 'bash.exe' 
        return self.__is_gitbash__

    def isGlobal(self):
        if not hasattr(self,'__is_global__'):
            self.__is_global__ = self.thisFile() == self.globalInstallPath()
        return self.__is_global__

    def isLinuxShell(self):
        return self.shellCmd() == '/bin/bash' or self.shellCmd() == '/bin/zsh' or \
            self.shellCmd() == '/bin/sh' or self.shellCmd() == '/bin/ash' or \
            self.shellCmd() == '/usr/bin/fish'

    def isLocal(self):
        if not hasattr(self, '__is_local__'):
            self.__is_local__=self.thisFile() == self.localInstallPath()
        return self.__is_local__

    def isSudo(self, sudo=None):
        if sudo is not None:
            self.__isSudo__=sudo
            return self
        elif not hasattr(self, '__isSudo__'):
            self.__isSudo__=False
        return self.__isSudo__

    def latest_version(self):
        useRequest = False
        try:
            if not hasattr(self,'__latest_version__'):
                majorVersion = 0
                minorVersion = 0
                lines = []
                result, stdout = self.curl_cmd( url=self.downloadUrl())
                if result:
                    lines = stdout.splitlines()
                for line in lines:
                    if 'setInstallation' in line and self.appName() in line:
                        for token in line.split(')')[0].split(','):
                            if 'majorVersion' in token:
                                majorVersion = int(token.split('=')[1])
                            if 'minorVersion' in token:
                                minorVersion = int(token.split('=')[1])
                self.__latest_version__="%d.%d" % (majorVersion,minorVersion)
                if majorVersion > self.majorVersion() or (majorVersion == self.majorVersion() and minorVersion> self.minorVersion()):
                    self.__need_update__=True
        except:
            self.msg_no_server()
        if not hasattr(self,'__latest_version__'):
            self.__latest_version__='0.0'
        return self.__latest_version__

    def lastUpdate(self, lastUpdate=None):
        if lastUpdate is not None:
            self.__lastUpdate__=lastUpdate
            return self
        elif not hasattr(self,'__lastUpdate__'):
            self.__lastUpdate__=None
        return self.__lastUpdate__

    def libcName(self, name=None):
        if name is not None:
            self.__libc_name__ = name
            return self
        elif not hasattr(self, '__libc_name__'):
            self.__libc_name__ = ''
        return self.__libc_name__

    def libcVersion(self, version=None):
        if version is not None:
            self.__libc_version__ = version
            return self
        elif not hasattr(self, '__libc_version__'):
            self.__libc_version__ = ''
        return self.__libc_version__

    def linuxDistro(self):
        if not hasattr(self, '__distro__'):
            self.__distro__=''
            if os.path.isfile("/etc/os-release"):
                fin = self.open("/etc/os-release", "rt")
                self.__distro__ = ''
                for line in fin:
                    if line.startswith('PRETTY_NAME='):
                        self.__distro__ = line.split('"')[1]
                if 'Alpine' in self.__distro__:
                    self.shellCmd("/bin/ash")
        return self.__distro__

    def local(self):
        return socket.gethostname()

    def localInstallFolder(self):
        if self.isCmd() or self.isGitBash():
            return 'C:\\Users\\%s\\AppData\\Local\\Microsoft\\WindowsApps' % self.username()
        else:  
            return os.path.abspath('%s/.local/bin' % self.home())

    def localInstallPath(self):
        if self.isCmd() or self.isGitBash():
            return '%s\\%s.bat' % (self.localInstallFolder(), self.appName())
        else:
            return os.path.abspath('%s/%s' % (self.localInstallFolder(), self.appName()))

    def majorVersion(self, majorVersion=None):
        if majorVersion is not None:
            self.__majorVersion__=majorVersion
            return self
        elif not hasattr(self,'__majorVersion__'):
            self.__majorVersion__=0
        return self.__majorVersion__

    def minorVersion(self, minorVersion=None):
        if minorVersion is not None:
            self.__minorVersion__=minorVersion
            return self
        elif not hasattr(self,'__minorVersion__'):
            self.__minorVersion__=0
        return self.__minorVersion__

    def mkdir(self, path):
        path = os.path.realpath(path)
        if not self.pathexists( path ):
            if self.osVersion() == 'windows':
                dir_split = path.split('\\')
                dirloc = dir_split[0]
                for dirlet in dir_split[1:]:
                    if dirlet != '':
                        dirloc = dirloc + '\\' + dirlet
                        if not self.pathexists(dirloc):
                            os.mkdir( dirloc )
            else:
                dir_split = path.split('/')
                dirloc = ''
                for dirlet in dir_split:
                    if dirlet != '':
                        dirloc = dirloc + '/' + dirlet
                        if not self.pathexists(dirloc):
                            os.mkdir( dirloc )

    def need_update(self):
        if not hasattr(self,'__need_update__'):
            self.__need_update__=False
            self.latest_version()
        return self.__need_update__

    def now(self):
        return str(datetime.now())

    def open(self, fname, sw):
        if self.isGitBash() or self.isCmd():
            fname = self.path_to_dos(fname)
        return open(fname, sw)

    def osVersion(self):
        if self.pathexists("/etc/os-release"):
            self.linuxDistro()
        if hasattr(self,'__distro__'):
            return self.__distro__
        self.__distro__  = ''
        if os.name == 'nt':
            self.__distro__='windows'
        elif self.shellCmd() != '':
            result, stdout = self.shell("sw_vers -productName")
            if result:
                self.__distro__ = stdout.strip()
        return self.__distro__

    def path_to_dos(self, path):
        # Avoid doing any os.path.realpath conversion
        split_path=path.split('/')
        count=0
        result=''
        for pathlet in split_path:
            # Avoid repeatively adding c:, it should not been there
            if pathlet!= '' and pathlet[-1] != ':':
                count = count + 1
                if count == 1:
                    if len(pathlet) == 1:
                        result = pathlet + ':'
                    else:
                        result = pathlet
                else:
                    result = result + '\\' + pathlet
        return result

    def parseArgs(self, usage, allowSelfInstall = True, allowDisplayInfo = True):
        if self.appPath() != '' :
            if len(sys.argv) > 1:
                self.cmd(sys.argv[1])
                if self.cmd() == "install" or self.cmd() == "update":
                    self.selfInstall()
                    return True
                elif self.cmd() == "this":
                    self.prn(self.this()) 
                    return True
                elif self.cmd() == "this-file":
                    self.prn(self.thisFile())
                    return True
                elif self.cmd() == "download":
                    self.download_to_temp(verbal=True)
                    return True
                elif self.cmd() == "download-app" or self.cmd() == "download-target-app":
                    self.download_to_temp(url=self.tempAppUrl(), file=self.tempTargetGzip(), verbal=True)
                    return True
                elif self.cmd() == "global-installation-path":
                    self.prn(self.globalInstallPath())
                    return True
                elif self.cmd() == "local-installation-path":
                    self.prn(self.localInstallPath())
                    return True
                elif self.cmd() == "uninstall":
                    self.selfUninstall()
                    return True
                elif self.cmd() == "check-update" or self.cmd() == "check-version"  or self.cmd() == "check":
                    self.checkUpdate()
                    return True
                elif allowDisplayInfo:
                    self.msg_info(usage)
                    return True
            elif allowDisplayInfo:
                self.msg_info(usage)
                return True
        elif allowSelfInstall:
            if self.fromPipe():
                self.download_and_install()
            else:
                self.selfInstall()
            return True
        else:
            return False

    def pathexists(self, path):
        if self.isGitBash():
            path=self.path_to_dos(path)
        return os.path.exists(path)

    def pid(self):
        return os.getpid()

    def prn(self, msg):
        print("%s" % msg)
        return self

    def pythonMajor(self, major=None):
        if major is not None:
            self.__python_major__ = major
            return self
        elif not hasattr(self, '__python_major__'):
            self.__python_major__ = 0
        return self.__python_major__

    def pythonMinor(self, minor=None):
        if minor is not None:
            self.__python_minor__ = minor
            return self
        elif not hasattr(self, '__python_minor__'):
            self.__python_minor__ = 0
        return self.__python_minor__

    def pythonName(self, name=None):
        if name is not None:
            self.__python_name__ = name
            return self
        elif not hasattr(self, '__python_name__'):
            self.__python_name__ = 0
        return self.__python_name__

    def pythonVersion(self, version=None):
        if version is not None:
            self.__python_version__ = version.strip()
            return self
        elif  hasattr(self, '__python_version__'):
            return self.__python_version__ 
        self.__python_version__ = sys.version
        if len(self.__python_version__.split('\n'))>1:
            self.__python_version__ =  self.__python_version__.split('\n')[0].strip()
        if len( self.__python_version__.split('['))>1:
            self.__python_version__ =  self.__python_version__.split('[')[0].strip()
        if len( self.__python_version__.split('('))>1:
            self.__python_version__ =  self.__python_version__.split('(')[0].strip()
        return self.__python_version__

    def realpath(self, x, curr_path=None):
        if curr_path is None:
            curr_path = self.curPath()
        if self.isCmd():
            if x[:1].startswith(':\\'):
                result=x
            elif x.startswith('..\\'):
                curr_path= '\\'.join(curr_path.split('\\')[:-1])
                if curr_path=='':
                    curr_path=self.curPath()
            result=self.path_to_dos('%s\\%s'% (os.getcwd(),x))
        else:
            if x.startswith('/'):
                result=x
            elif x.startswith('../../'):
                x=x[6:]
                curr_path = '/'.join(curr_path.split('/')[:-2])
            elif x.startswith('../'):
                x=x[3:]
                curr_path = '/'.join(curr_path.split('/')[:-1])
            result='%s/%s' % (curr_path,x)
        return result

    def removeFile(self, filePath):
        if self.isCmd() or self.isGitBash():
            filePath=self.path_to_dos(filePath)
        if self.pathexists(filePath):         
            os.remove(filePath)

    def removeFilePattern(self, dirPath, pattern):
        if self.pathexists(dirPath) and os.path.isdir(dirPath):
            for file in os.listdir(dirPath):
                if file.endswith(pattern):
                    self.removeFile("%s/%s" % (dirPath,file))

    def removeFolder(self, dirPath):
        if self.isCmd() or self.isGitBash():
            dirPath=self.path_to_dos(dirPath)
        if self.pathexists(dirPath) and os.path.isdir(dirPath):
            shutil.rmtree(dirPath)

    def safeMsg(self,msg,tag=''):
        self.__tag__(tag).__message__(msg).__timeMsg__(AppBase.BOLD + AppBase.ITALICS + \
            AppBase.DARK_TURQUOISE) \
            .__header__(AppBase.BOLD + AppBase.DARK_TURQUOISE) \
            .__coloredMsg__(AppBase.ITALICS + AppBase.LIGHT_TURQUOISE) \
            .__tagMsg__(AppBase.LIGHT_GREEN,AppBase.LIGHT_TURQUOISE)
        self.prn("%s" % (self.__formattedMsg__()))
        return self

    def selfInstall(self, verbal = True):
        if self.isGlobal():
            if self.need_update():
                self.msg_old_global()
                if self.ask_update():
                    return self.download_and_install(verbal)
            else:
                self.msg_latest_global()
                return False
        elif self.isLocal():
            if self.need_update():
                self.msg_old_local()
                if self.ask_update():  
                    return self.download_and_install(verbal)
            else:
                self.msg_latest_local()
                return False
        elif self.installedGlobal():
            self.msg_global_already()
            if self.ask_overwrite_global():
                return self.__self_install__(self.thisFile(), verbal)
        elif self.installedLocal():
            self.msg_local_already()
            if self.ask_overwrite_local():  
                return self.install_local(verbal)
        elif self.username() != 'root':
            if self.ask_local():
                return self.install_local(verbal)
        else:
            return self.__self_install_globally__(verbal)

    def selfLocation(self):
        if self.thisFile() != '':
            return self.thisFile()
        try:
            shell = get_ipython().__class__.__name__
            if shell == 'ZMQInteractiveShell':
                return "Jupyter"
            elif shell == 'TerminalInteractiveShell':
                return "IPython"
            else:
                return "Unknown location"
        except NameError:
            return "Unknown location" 
        
    def selfUninstallGlobal(self, verbal = True):
        if self.installedGlobal():
            result = False
            if self.username() != 'root':
                if self.sudo_test():
                    self.sudoRemoveFile(self.globalInstallPath())
                    result = True
                else:
                    self.msg_unintall_need_root()
            else:
                self.removeFile(self.globalInstallPath())
                result = True
            if result:
                if self.targetApp() != '':
                    self.removeFile("%s/%s" % (self.globalInstallRoot(), self.targetApp()))
                if verbal:
                    self.msg_unintall_global()
            else:
                self.msg_global_failed()
            return result
        else:
            self.msg_no_global()
        return False

    def selfUninstall(self, verbal=True):
        if self.installedLocal():
            self.selfUninstallLocal(verbal)
        elif self.installedGlobal():
            self.selfUninstallGlobal(verbal)
        else:
            self.msg_no_installation()    

    def selfUninstallLocal(self, verbal = True):
        if self.installedLocal():
            self.removeFile(self.localInstallPath())
            if not os.path.exists(self.localInstallPath()):
                if self.targetApp() != '':
                    self.removeFile("%s/%s" % (self.localInstallFolder(), self.targetApp()))
                if verbal:
                    self.msg_uninstall_local()
                return True
            else:
                self.msg_uninstall_local_failed()
                return False
        else:
            self.msg_no_local()
            return False

    def setInstallation(self,appName='',author='',lastUpdate='',homepage='',downloadUrl="",majorVersion=0,minorVersion=0):
        signal.signal(signal.SIGINT, self.signal_handler)
        self.checkSystem()
        self.author( author )
        self.appName( appName )
        self.downloadUrl( downloadUrl )
        self.homepage( homepage )
        self.lastUpdate( lastUpdate )
        self.majorVersion( majorVersion )
        self.minorVersion( minorVersion )

    def shell(self, command, ignoreErr=False):
        stderr = ''
        stdout = ''
        if self.isLinuxShell() or self.isGitBash():
            stdout,stderr = Popen([self.shellCmd(),'-c',command],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        elif self.isCmd():
            stdout,stderr = Popen([self.shellCmd(),'/c',command],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        else:
            # Assume /bin/sh as default shell
            stdout,stderr = Popen(['/bin/sh','-c',command],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        if stderr != "" and not ignoreErr:
            self.msg_error(command, stderr)
            return False, stderr
        else:
            return True, stdout

    def shellCmd(self, cmd=None):
        if cmd is not None:
            self.__shell_cmd__=cmd
            return self
        elif not hasattr(self,'__shell_cmd__'):
            if 'SHELL' in os.environ:
                self.__shell_cmd__ = os.environ['SHELL']
                # cannot use self.pathexists to avoid recursive call
            elif os.path.exists('/usr/bin/fish'):
                self.__shell_cmd__ = '/usr/bin/fish'
            elif os.path.exists('/bin/bash'):
                self.__shell_cmd__ = '/bin/bash'
            elif os.path.exists('/bin/ash'):
                self.__shell_cmd__ = '/bin/ash'
            elif os.path.exists('/bin/zsh'):
                self.__shell_cmd__ = '/bin/zsh'
            elif os.path.exists('/bin/sh'):
                self.__shell_cmd__ = '/bin/sh'
            elif os.path.exists('C:\\Windows\\System32\\cmd.exe'):
                self.__shell_cmd__ = 'C:\\Windows\\System32\\cmd.exe'
            else:
                self.__shell_cmd__=''
        return self.__shell_cmd__

    def signal_handler(self, sig, frame):
        self.prn('\nYou pressed Ctrl+C!')
        sys.exit(0)

    def sudo_test(self,msg='.'):
        distro = self.osVersion()
        if distro == 'windows':
            self.isSudo(False)
            return False
        if self.isSudo():
            return True
        if distro.startswith('Alpine'):
            stdout,stderr = Popen([ self.shellCmd(), '-c' , "which sudo" ],\
                stdin=PIPE,stdout=PIPE,stderr=PIPE,universal_newlines=True)\
                .communicate( '\n' )
            if stdout=='':
                return False
        stdout,stderr = Popen([ self.shellCmd(), '-c' , "sudo echo %s" % msg ],\
            stdin=PIPE,stdout=PIPE,stderr=PIPE,universal_newlines=True)\
            .communicate( '\n' )
        trial=0
        while stdout.strip() != msg.strip() and trial < 3:
            sudoPassword=getpass.getpass( 'Please input "sudo" password for %s: ' % self.username() )
            stdout, stderr = Popen([ self.shellCmd() , '-c',"sudo echo %s" % msg ] \
                ,stdin=PIPE,stdout=PIPE,stderr=PIPE,\
                universal_newlines=True ).communicate( "%s\n" % sudoPassword )
            trial=trial + 1
        if trial < 3:
            self.isSudo( True )
        return self.isSudo()

    def sudoRemoveFile(self, filePath):
        self.shell( 'sudo rm -rf %s' % filePath )

    def tag(self, tag=None):
        if tag is not None:
            self.__TAG__=tag
            return self
        elif not hasattr( self, '__TAG__' ):
            self.__TAG__=''
        return self.__TAG__

    def targetApp(self, app=None):
        if app is not None:
            self.__target_app__=app
            return self
        elif not hasattr( self, '__target_app__' ):
            self.__target_app__=''
        return self.__target_app__

    def tempAppUrl(self):
        if self.downloadUrl()[-1] == '/':
            return "%s%s/%d.%d/%s.tar.gz" % (self.downloadUrl(), self.binaryVersion(), self.majorVersion(),self.minorVersion(), self.targetApp())
        else:
            return "%s/%s/%d.%d/%s.tar.gz" % (self.downloadUrl(), self.binaryVersion(), self.majorVersion(),self.minorVersion(), self.targetApp())

    def tempTargetGzip(self):
        timestamp = self.timestamp()
        if self.isLinuxShell():
            return "%s/%s-%s.tar.gz" % (self.tempFolder(), self.targetApp(), timestamp)
        elif self.isGitBash() or self.isCmd():
            return "%s\\%s-%s.tar.gz" % (self.tempFolder(), self.targetApp(), timestamp)
        return "%s/%s-%s.tar.gz" % (self.tempFolder(), self.targetApp(), timestamp)

    def tempAttachDecomp(self):
        if self.isCmd():
            fname="%s\\%s" % (self.tempFolder(),self.targetApp())
        elif self.isGitBash():
            fname="%s/%s" % (self.tempFolder(),self.targetApp())
        else:
            fname="%s/%s" % (self.tempFolder(), self.targetApp())
        return fname

    def tempFile(self):
        if self.isCmd():
            fname="%s\\%s-%s.bat" % (self.tempFolder(), self.appName(),self.timestamp())
        elif self.isGitBash():
            # GitBash download location should remain the same such that starting with /c/Users/user...
            fname="%s/%s-%s.bat" % (self.tempFolder(), self.appName(),self.timestamp())
        else:
            fname="%s/%s-%s" % (self.tempFolder(), self.appName(),self.timestamp())
        return fname

    def tempFolder(self):
        if self.isGitBash():
            folder="/C/Users/%s/AppData/Local/Temp" % self.username()
        elif 'TEMP' in os.environ:
            folder=os.environ['TEMP']
        elif self.isCmd():
            folder="C:\\Users\\%s\\AppData\\Local\\Temp" % self.username()
        elif self.username() == 'root':
            folder="/tmp" 
        elif self.osVersion() == 'macOS':
            folder = '/Users/%s/Library/Caches' % self.username()
        else:
            folder="/home/%s/.local/temp" % self.username()
            self.mkdir(folder)
        return folder

    def this(self, this = None):
        if this is None :
            if not hasattr(self, '__this__'):
                self.__this__=self.appPath()
            return self.__this__
        else:
            self.__this__ = this
            return self

    @staticmethod
    def thisFile():
        return AppBase.__here__

    def timestamp(self):
        return "%s" % (int(time.time()))

    def where_cmd(self, cmd):
        stdout = ''
        if self.isCmd() or self.isGitBash():
            result, stdout = self.shell("where %s" % cmd, ignoreErr=True)
            result = ''
            final = ''
            for line in stdout.splitlines():
                result = line.strip()
                if 'Windows' in result and 'System32' in result:
                    final = result
            if final == '':
                final = result
            return final
        if self.isLinuxShell():
            return self.which_cmd(cmd)

    def which(self):
        if self.pathexists('/usr/bin/which'):
            return self.which_cmd( self.appName())
        elif self.pathexists('C:\\Windows\\System32\\where.exe'):
            return self.which_cmd( self.appName())
        elif self.pathexists(self.localInstallPath()):
            return self.localInstallPath()
        elif self.pathexists(self.globalInstallPath()):
            return self.globalInstallPath()
        else:
            return ""

    def which_cmd(self, cmd):
        stdout = ''
        if self.isCmd() or self.isGitBash():
            return self.where_cmd(cmd)
        elif self.isLinuxShell():
            if os.path.exists('/usr/bin/which'):
                result, stdout = self.shell("/usr/bin/which %s" % cmd, ignoreErr=True)
                return stdout.strip()
            elif os.path.exists('/bin/which'):
                result, stdout = self.shell("/usr/bin/which %s" % cmd, ignoreErr=True)
                return stdout.strip()
            elif os.path.exists('/bin/%s' % cmd):
                return '/bin/%s' % cmd
            elif os.path.exists('/usr/bin/%s' % cmd):
                return '/usr/bin/%s' % cmd
            elif os.path.exists('/usr/bin/local/%s' % cmd):
                return '/usr/bin/local/%s' % cmd
            elif os.path.exists('/home/%s/.local/bin/%s' % [self.username(), cmd]):
                return '/home/%s/.local/bin/%s' % [self.username(), cmd]
            elif 'PATH' in os.environ:
                split_path = os.environ['PATH'].split(':')
                for pathlet in split_path:
                    if self.pathexists('%s/%s' % [pathlet, cmd]):
                        return '%s/%s' % [pathlet, cmd]
        return ''

    def uname(self, switch, ignoreErr=True):
        stderr = ''
        stdout = ''
        command = 'uname %s' % switch
        if self.isLinuxShell():
            uname = self.which_cmd('uname')
            stdout,stderr = Popen([uname,switch],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        if self.isGitBash():
            winpty = self.where_cmd('winpty.exe')
            uname = self.where_cmd('uname')
            stdout,stderr = Popen([winpty, uname,switch],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
            if stderr.strip().lower() == 'stdin is not a tty':
                stdout,stderr = Popen([uname,switch],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        elif self.isCmd():
            stdout,stderr = Popen([self.shellCmd(),'/c',command],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        else:
            # Assume /bin/sh as default shell
            uname = self.which_cmd('uname')
            stdout,stderr = Popen([uname,switch],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        if stderr != "" and not ignoreErr:
            self.msg_error(command, stderr)
            return False, stderr
        else:
            return True, stdout

    def uname_a(self, ignoreErr=True):
        return self.uname('-a')

    def uname_m(self, ignoreErr=True):
        return self.uname('-m')

    def useColor(self, color=None):
        if color is not None:
            self.__useColor__=color
            return self
        elif not hasattr(self, '__useColor__'):
            if self.isGitBash():
                # Gitbash cannot show color
                self.__useColor__=False
            else:
                self.__useColor__=True
        return self.__useColor__

    def userID(self):
        return os.getuid()

    def username(self):
        if pwd is None:
            return os.getlogin()
        return pwd.getpwuid(self.userID())[0]

    def version(self):
        return "%s.%s" % (self.majorVersion(),self.minorVersion())

    def zshenv(self):
        return os.path.join(self.home(), ".zshenv")

    def ask_local(self):
        return 'yes' == self.__ask_yesno__('Do you want to install locally? (yes/no) ')

    def ask_overwrite_global(self):
        return 'yes' == self.__ask_yesno__('Do you want to overwrite the global installation? (yes/no) ')

    def ask_overwrite_local(self):
        return 'yes' == self.__ask_yesno__('Do you want to overwrite the local installation? (yes/no) ')

    def ask_update(self):
        return 'yes' == self.__ask_yesno__('Do you want to update the latest (%s) from internet? (yes/no) ' % self.latest_version())

    def msg_alpine_detected(self):
        self.infoMsg("Alpine Detected!", "OPERATION SYSTEM")

    def msg_both_local_global(self):
        self.criticalMsg("It may causes error if you have installed both local version and Global Version!\n  Please uninstall local version by,\n    %s uninstall" % self.appPath(), "INSTALLED TWICE")

    def msg_download_error(self, file):
        if not hasattr(self,'__msgshown_download_error__'):
            self.criticalMsg("Download file error: %s" % file, "DOWNLOAD ERROR")
            self.__msgshown_download_error__=True

    def msg_download_url_error(self, url, code):
        if not hasattr(self,'__msgshown_download_error__'):
            self.criticalMsg("Url: %s\n  HTTP code: %s" % (url, code), "DOWNLOAD ERROR")
            self.__msgshown_download_error__=True

    def msg_download_not_found(self, file):
        self.criticalMsg("Downloaded File: %s" % file, "NOT FOUND")

    def msg_downloaded(self, fname):
        self.safeMsg("File downloaded to: %s" % fname, "DOWNLOADED")

    def msg_downloading(self, url):
        self.infoMsg("Downloading: %s ..." % url,"DOWNLOAD FILES")

    def msg_error(self, command, stderr):
        self.criticalMsg("Error in %s: %s" % (command, stderr), "ERROR")

    def msg_extraction_error(self, file):
        self.criticalMsg("File Extraction error: %s not found" % file, "DOWNLOAD ERROR")

    def msg_global_already(self):
        self.infoMsg("Global Installation installed already!", "SELF INSTALL")

    def msg_info(self, usage=""):
        if self.isCmd():
            msg1="%s.bat (%s.%s) by %s on %s" % (self.appName(),self.majorVersion(),\
                self.minorVersion(),self.author(),self.lastUpdate())
        else:
            msg1="%s (%s.%s) by %s on %s" % (self.appName(),self.majorVersion(),\
                self.minorVersion(),self.author(),self.lastUpdate())
        if self.isGlobal():
            app = "You are using the GLOBAL INSTALLED version, location:"
        elif self.isLocal():
            app = "You are using the LOCAL INSTALLED version, location:"
        else :
            app = "You are using an UNINSTALLED version, location:" 
        arch = self.arch()
        python_exe = self.executable()
        if python_exe == '':
            python_exe = self.pythonName()
        msg = [
            msg1, 
            "Python %s" % self.pythonVersion(),
            "Shell: %s" % self.shellCmd(),
            "Operation System: %s %s" % (self.osVersion(), self.libcVersion() ), 
            "Architecture: %s" % arch,
            '',
            '%s' % app,
            '    %s' % self.selfLocation(),
            '', 
            "Basic Usage:",
            "    %s" % usage,
            '',
            'Please visit our homepage: ',
            '    "%s"' % self.homepage(),
            '',
            'Installation command:',
            '    curl -fsSL %s|%s' % (self.downloadUrl(), python_exe),
            ''
        ]
        starLine=[]
        space=[]
        spaces=[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
        maxLen=len(msg[0])
        if self.downloadUrl() == '':
            if self.homepage() == '':
                max_line = 15
            else:
                max_line = 16
        else:
            max_line = 17
        for n in range(1, max_line):
            if len(msg[n]) > maxLen :
                maxLen=len(msg[n])
        for n in range(0, max_line):
            for i in range(1,maxLen - len(msg[n]) + 1):
                spaces[n].append(' ')
            msg[n]=msg[n] + ''.join(spaces[n])
        for i in range(1,maxLen + 5):
            starLine.append("*")
        for i in range(1,maxLen + 1):
            space.append(" ")
        self.prn(''.join(starLine))
        self.prn('* %s *' % ''.join(space))
        for n in range(0, max_line):
            self.prn('* %s *' % msg[n])
        self.prn('* %s *' % ''.join(space))
        self.prn(''.join(starLine))

    def msg_install_app_global(self):
        if self.isCmd() or self.isGitBash():
            self.msg_install('Globally', "%s.bat" % self.appName() )
        else:
            self.msg_install('Globally', self.appName())

    def msg_install_app_local(self):
        if self.isCmd() or self.isGitBash():
            self.msg_install('Locally', "%s.bat" % self.appName() )
        else:
            self.msg_install('Locally', self.appName())

    def msg_install(self, location, app):
        startSh =  ""   # for ash, cmd, gitbash
        if location == 'Locally':
            if self.osVersion() == 'macOS':
                startSh = "  Please type 'hash -r' and 'source ~/.zshenv' to refresh zsh shell hash!\n  Then, you can "
            elif self.shellCmd() != '/bin/ash' and self.isLinuxShell():
                startSh =  "  Please type 'hash -r' and 'source ~/.bashrc' to refresh bash shell hash!\n  Then, you can "
            self.safeMsg("Installed %s! \n%s  type '%s' to run!" % (location, startSh, app), "INSTALL")
        else:
            self.safeMsg("Installed %s! \n    type '%s' to run!" % (location, app), "INSTALL")

    def msg_install_target_global(self):
        if self.isCmd() or self.isGitBash():
            self.msg_install('Globally', "%s.bat" % self.targetApp() )
        else:
            self.msg_install('Globally', self.targetApp())

    def msg_install_target_local(self):
        if self.isCmd() or self.isGitBash():
            self.msg_install('Locally', "%s.bat" % self.targetApp() )
        else:
            self.msg_install('Locally', self.targetApp())

    def msg_latest(self):
        if self.isLocal():
            self.msg_latest_global()
        elif self.isLocal():
            self.msg_latest_local()
        else:
            self.infoMsg("You are using latest (%s.%s) already!" % (self.majorVersion(),self.minorVersion()), "CHECK VERSION")

    def msg_latest_global(self):
        self.infoMsg("You are using latest (%s.%s) Global Installation's copy already!" % (self.majorVersion(),self.minorVersion()), "CHECK VERSION")

    def msg_latest_local(self):
        self.infoMsg("You are using latest (%s.%s) Local Installation's copy already!" % (self.majorVersion(),self.minorVersion()), "CHECK VERSION")

    def msg_latest_available(self):
        self.infoMsg("Latest Version = %s\n  Update is available" % self.latest_version(), "CHECK UPDATE")

    def msg_local_already(self):
        self.infoMsg("Local Installation installed already!", "SELF INSTALL")

    def msg_no_global(self):
        self.infoMsg("You don't have any local installation.", "GLOBAL UNINSTALL")

    def msg_no_local(self):
        self.infoMsg("You don't have any local installation.", "LOCAL UNINSTALL")

    def msg_no_server(self):
        self.criticalMsg("Cannot communicate with server", "CONNECTION FAILED")

    def msg_no_installation(self):
        self.infoMsg("You don't have any global or local installation.", "UNINSTALL")

    def msg_root_continue(self):
        self.criticalMsg("You must be root to continue installation!", "SELF INSTALL")

    def msg_old_global(self):
        self.infoMsg("You are using an old (%s.%s) Global Installation's copy already!" % (self.majorVersion(),self.minorVersion()) , "SELF INSTALL")

    def msg_old_local(self):
        self.infoMsg("You are using an old (%s.%s) Local Installation's copy already!" % (self.majorVersion(),self.minorVersion()), "SELF INSTALL")

    def msg_sudo_failed(self):
        self.criticalMsg("You should be root or sudo to install globally.", "SUDO FAILED")

    def msg_system_check(self):
        if not hasattr(self,'__system_msg_shown__'):
            self.safeMsg("Now checking your operation system!", "START")
            self.prn("    Python: %s" % self.pythonVersion())
            self.prn("    C Library: %s" % self.libcVersion())
            self.prn("    Operation System: %s" % self.osVersion())
            self.prn("    Current User: %s" % self.username())
            self.prn("    Shell: %s" % self.shellCmd())
            self.prn("    Python Executable: %s" % self.executable())
            self.prn("    Binary Version: %s" % self.binaryVersion() )
            self.prn("")
            self.__system_msg_shown__ = True

    def msg_timeout(self, file):
        self.criticalMsg("Time out in downloading %s" % (file), "ERROR")

    def msg_unintall_global(self):
        self.infoMsg("You have uninstalled successfully.", "GLOBAL UNINSTALL")

    def msg_uninstall_global_failed(self):
        self.criticalMsg("Failed to uninstall globally", "UNINSTALL FAILED")

    def msg_uninstall_local(self):
        self.infoMsg("You have uninstalled successfully.", "LOCAL UNINSTALL")

    def msg_uninstall_local_failed(self):
        self.criticalMsg("Failed to uninstall locally", "UNINSTALL FAILED")

    def msg_unintall_need_root(self):
        self.criticalMsg("You should be root or sudo to uninstall globally.", "GLOBAL UNINSTALL")

class OnlineInstaller(AppBase):

    def start(self):
        self.allowInstallLocal(True)
        usage = "%s [check-update|install|uninstall]" % self.appExec()
        if not self.parseArgs(usage):
            self.msg_info(usage)

if __name__ == "__main__":
    app = OnlineInstaller()
    app.targetApp('spanish-num')
    app.setInstallation(appName='spanish-num-installer',author='Cloudgen Wong',homepage="https://github.com/cloudgen2/spanish-num",downloadUrl="https://dl.leolio.page/spanish-num",lastUpdate='2023-10-14',majorVersion=0,minorVersion=4)
    app.start() 

